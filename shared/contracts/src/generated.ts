/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * RAG Corp API
 * OpenAPI spec version: 0.1.0
 */
export interface ArchiveWorkspaceRes {
  archived: boolean;
}

export type AskResConversationId = string | null;

export interface AskRes {
  answer: string;
  sources: string[];
  conversation_id?: AskResConversationId;
}

export type BodyUploadDocumentApiV1DocumentsUploadPostTitle = string | null;

export type BodyUploadDocumentApiV1DocumentsUploadPostSource = string | null;

export type BodyUploadDocumentApiV1DocumentsUploadPostMetadata = string | null;

export interface BodyUploadDocumentApiV1DocumentsUploadPost {
  file: Blob;
  title?: BodyUploadDocumentApiV1DocumentsUploadPostTitle;
  source?: BodyUploadDocumentApiV1DocumentsUploadPostSource;
  metadata?: BodyUploadDocumentApiV1DocumentsUploadPostMetadata;
}

export type BodyUploadDocumentV1DocumentsUploadPostTitle = string | null;

export type BodyUploadDocumentV1DocumentsUploadPostSource = string | null;

export type BodyUploadDocumentV1DocumentsUploadPostMetadata = string | null;

export interface BodyUploadDocumentV1DocumentsUploadPost {
  file: Blob;
  title?: BodyUploadDocumentV1DocumentsUploadPostTitle;
  source?: BodyUploadDocumentV1DocumentsUploadPostSource;
  metadata?: BodyUploadDocumentV1DocumentsUploadPostMetadata;
}

export type BodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostTitle = string | null;

export type BodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostSource = string | null;

export type BodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostMetadata = string | null;

export interface BodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost {
  file: Blob;
  title?: BodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostTitle;
  source?: BodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostSource;
  metadata?: BodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostMetadata;
}

export type BodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostTitle = string | null;

export type BodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostSource = string | null;

export type BodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostMetadata = string | null;

export interface BodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost {
  file: Blob;
  title?: BodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostTitle;
  source?: BodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostSource;
  metadata?: BodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostMetadata;
}

export interface CreateUserRequest {
  /**
   * @minLength 3
   * @maxLength 320
   */
  email: string;
  /**
   * @minLength 8
   * @maxLength 512
   */
  password: string;
  role?: UserRole;
}

export type CreateWorkspaceReqOwnerUserId = string | null;

export interface CreateWorkspaceReq {
  /**
   * Workspace name
   * @minLength 1
   * @maxLength 200
   */
  name: string;
  visibility?: WorkspaceVisibility;
  owner_user_id?: CreateWorkspaceReqOwnerUserId;
  acl?: WorkspaceACL;
}

export interface DeleteDocumentRes {
  deleted: boolean;
}

export type DocumentDetailResSource = string | null;

export type DocumentDetailResMetadata = { [key: string]: unknown };

export type DocumentDetailResCreatedAt = string | null;

export type DocumentDetailResFileName = string | null;

export type DocumentDetailResMimeType = string | null;

export type DocumentDetailResStatus = string | null;

export type DocumentDetailResDeletedAt = string | null;

export type DocumentDetailResErrorMessage = string | null;

export interface DocumentDetailRes {
  id: string;
  title: string;
  source: DocumentDetailResSource;
  metadata: DocumentDetailResMetadata;
  created_at: DocumentDetailResCreatedAt;
  file_name?: DocumentDetailResFileName;
  mime_type?: DocumentDetailResMimeType;
  status?: DocumentDetailResStatus;
  tags?: string[];
  deleted_at?: DocumentDetailResDeletedAt;
  error_message?: DocumentDetailResErrorMessage;
}

export type DocumentSummaryResSource = string | null;

export type DocumentSummaryResMetadata = { [key: string]: unknown };

export type DocumentSummaryResCreatedAt = string | null;

export type DocumentSummaryResFileName = string | null;

export type DocumentSummaryResMimeType = string | null;

export type DocumentSummaryResStatus = string | null;

export interface DocumentSummaryRes {
  id: string;
  title: string;
  source: DocumentSummaryResSource;
  metadata: DocumentSummaryResMetadata;
  created_at: DocumentSummaryResCreatedAt;
  file_name?: DocumentSummaryResFileName;
  mime_type?: DocumentSummaryResMimeType;
  status?: DocumentSummaryResStatus;
  tags?: string[];
}

export type DocumentsListResNextCursor = string | null;

export interface DocumentsListRes {
  documents: DocumentSummaryRes[];
  next_cursor?: DocumentsListResNextCursor;
}

/**
 * Application error codes for client-side handling.
 */
export type ErrorCode = typeof ErrorCode[keyof typeof ErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorCode = {
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  UNAUTHORIZED: 'UNAUTHORIZED',
  FORBIDDEN: 'FORBIDDEN',
  NOT_FOUND: 'NOT_FOUND',
  CONFLICT: 'CONFLICT',
  UNSUPPORTED_MEDIA: 'UNSUPPORTED_MEDIA',
  RATE_LIMITED: 'RATE_LIMITED',
  PAYLOAD_TOO_LARGE: 'PAYLOAD_TOO_LARGE',
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',
  LLM_ERROR: 'LLM_ERROR',
  EMBEDDING_ERROR: 'EMBEDDING_ERROR',
  DATABASE_ERROR: 'DATABASE_ERROR',
} as const;

export type ErrorDetailInstance = string | null;

export type ErrorDetailErrorsAnyOfItem = { [key: string]: unknown };

export type ErrorDetailErrors = ErrorDetailErrorsAnyOfItem[] | null;

/**
 * RFC 7807 Problem Details response.
 */
export interface ErrorDetail {
  type?: string;
  title: string;
  status: number;
  detail: string;
  code: ErrorCode;
  instance?: ErrorDetailInstance;
  errors?: ErrorDetailErrors;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface IngestBatchReq {
  /**
   * List of documents to ingest (1-10)
   * @minItems 1
   * @maxItems 10
   */
  documents: IngestTextReq[];
}

export interface IngestBatchRes {
  documents: IngestTextRes[];
  total_chunks: number;
}

/**
 * Optional source URL or identifier (max 500 chars)
 */
export type IngestTextReqSource = string | null;

/**
 * Additional custom metadata (JSONB)
 */
export type IngestTextReqMetadata = { [key: string]: unknown };

export interface IngestTextReq {
  /**
   * Document title (1-200 chars)
   * @minLength 1
   * @maxLength 200
   */
  title: string;
  /**
   * Full document text to be chunked (1-100,000 chars)
   * @minLength 1
   * @maxLength 100000
   */
  text: string;
  /** Optional source URL or identifier (max 500 chars) */
  source?: IngestTextReqSource;
  /** Additional custom metadata (JSONB) */
  metadata?: IngestTextReqMetadata;
}

export interface IngestTextRes {
  document_id: string;
  chunks: number;
}

export interface LoginRequest {
  /**
   * @minLength 3
   * @maxLength 320
   */
  email: string;
  /**
   * @minLength 1
   * @maxLength 512
   */
  password: string;
}

export interface LoginResponse {
  access_token: string;
  token_type?: string;
  expires_in: number;
  user: UserResponse;
}

export interface Match {
  chunk_id: string;
  document_id: string;
  content: string;
  score: number;
}

/**
 * Conversation ID for multi-turn chat (optional)
 */
export type QueryReqConversationId = string | null;

export interface QueryReq {
  /**
   * User's natural language question (1-2,000 chars)
   * @minLength 1
   * @maxLength 2000
   */
  query: string;
  /** Conversation ID for multi-turn chat (optional) */
  conversation_id?: QueryReqConversationId;
  /**
   * Number of similar chunks to retrieve (1-20)
   * @minimum 1
   * @maximum 20
   */
  top_k?: number;
  /** Use Maximal Marginal Relevance for diverse results (slower but reduces redundancy) */
  use_mmr?: boolean;
}

export interface QueryRes {
  matches: Match[];
}

export interface ReprocessDocumentRes {
  document_id: string;
  status: string;
  enqueued: boolean;
}

export interface ResetPasswordRequest {
  /**
   * @minLength 8
   * @maxLength 512
   */
  password: string;
}

export interface ShareWorkspaceReq {
  /** List of user IDs to grant read access */
  user_ids: string[];
}

/**
 * Workspace name
 */
export type UpdateWorkspaceReqName = string | null;

/**
 * Workspace description
 */
export type UpdateWorkspaceReqDescription = string | null;

export interface UpdateWorkspaceReq {
  /** Workspace name */
  name?: UpdateWorkspaceReqName;
  /** Workspace description */
  description?: UpdateWorkspaceReqDescription;
}

export interface UploadDocumentRes {
  document_id: string;
  status: string;
  file_name: string;
  mime_type: string;
}

export type UserResponseCreatedAt = string | null;

export interface UserResponse {
  id: string;
  email: string;
  role: UserRole;
  is_active: boolean;
  created_at: UserResponseCreatedAt;
}

/**
 * R: Supported user roles for JWT auth.
 */
export type UserRole = typeof UserRole[keyof typeof UserRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserRole = {
  admin: 'admin',
  employee: 'employee',
} as const;

export interface UsersListResponse {
  users: UserResponse[];
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export interface WorkspaceACL {
  allowed_roles?: string[];
}

export type WorkspaceResOwnerUserId = string | null;

export type WorkspaceResCreatedAt = string | null;

export type WorkspaceResUpdatedAt = string | null;

export type WorkspaceResDeletedAt = string | null;

export interface WorkspaceRes {
  id: string;
  name: string;
  visibility: WorkspaceVisibility;
  owner_user_id?: WorkspaceResOwnerUserId;
  acl: WorkspaceACL;
  created_at?: WorkspaceResCreatedAt;
  updated_at?: WorkspaceResUpdatedAt;
  deleted_at?: WorkspaceResDeletedAt;
}

/**
 * R: Workspace visibility options.
 */
export type WorkspaceVisibility = typeof WorkspaceVisibility[keyof typeof WorkspaceVisibility];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WorkspaceVisibility = {
  PRIVATE: 'PRIVATE',
  ORG_READ: 'ORG_READ',
  SHARED: 'SHARED',
} as const;

export interface WorkspacesListRes {
  workspaces: WorkspaceRes[];
}

export type ListWorkspacesV1WorkspacesGetParams = {
owner_user_id?: string | null;
include_archived?: boolean;
};

export type ListDocumentsV1DocumentsGetParams = {
workspace_id?: string | null;
q?: string | null;
status?: string | null;
tag?: string | null;
sort?: string | null;
cursor?: string | null;
/**
 * @minimum 1
 * @maximum 200
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
};

export type GetDocumentV1DocumentsDocumentIdGetParams = {
workspace_id?: string | null;
};

export type DeleteDocumentV1DocumentsDocumentIdDeleteParams = {
workspace_id?: string | null;
};

export type UploadDocumentV1DocumentsUploadPostParams = {
workspace_id?: string | null;
};

export type ReprocessDocumentV1DocumentsDocumentIdReprocessPostParams = {
workspace_id?: string | null;
};

export type IngestTextV1IngestTextPostParams = {
workspace_id?: string | null;
};

export type IngestBatchV1IngestBatchPostParams = {
workspace_id?: string | null;
};

export type QueryV1QueryPostParams = {
workspace_id?: string | null;
};

export type AskV1AskPostParams = {
workspace_id?: string | null;
};

export type AskStreamV1AskStreamPostParams = {
workspace_id?: string | null;
};

export type ListWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetParams = {
q?: string | null;
status?: string | null;
tag?: string | null;
sort?: string | null;
cursor?: string | null;
/**
 * @minimum 1
 * @maximum 200
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
};

export type ListWorkspacesApiV1WorkspacesGetParams = {
owner_user_id?: string | null;
include_archived?: boolean;
};

export type ListDocumentsApiV1DocumentsGetParams = {
workspace_id?: string | null;
q?: string | null;
status?: string | null;
tag?: string | null;
sort?: string | null;
cursor?: string | null;
/**
 * @minimum 1
 * @maximum 200
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
};

export type GetDocumentApiV1DocumentsDocumentIdGetParams = {
workspace_id?: string | null;
};

export type DeleteDocumentApiV1DocumentsDocumentIdDeleteParams = {
workspace_id?: string | null;
};

export type UploadDocumentApiV1DocumentsUploadPostParams = {
workspace_id?: string | null;
};

export type ReprocessDocumentApiV1DocumentsDocumentIdReprocessPostParams = {
workspace_id?: string | null;
};

export type IngestTextApiV1IngestTextPostParams = {
workspace_id?: string | null;
};

export type IngestBatchApiV1IngestBatchPostParams = {
workspace_id?: string | null;
};

export type QueryApiV1QueryPostParams = {
workspace_id?: string | null;
};

export type AskApiV1AskPostParams = {
workspace_id?: string | null;
};

export type AskStreamApiV1AskStreamPostParams = {
workspace_id?: string | null;
};

export type ListWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetParams = {
q?: string | null;
status?: string | null;
tag?: string | null;
sort?: string | null;
cursor?: string | null;
/**
 * @minimum 1
 * @maximum 200
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
};

export type HealthzHealthzGetParams = {
full?: boolean;
};

export type HTTPStatusCode1xx = 100 | 101 | 102 | 103;
export type HTTPStatusCode2xx = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207;
export type HTTPStatusCode3xx = 300 | 301 | 302 | 303 | 304 | 305 | 307 | 308;
export type HTTPStatusCode4xx = 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 419 | 420 | 421 | 422 | 423 | 424 | 426 | 428 | 429 | 431 | 451;
export type HTTPStatusCode5xx = 500 | 501 | 502 | 503 | 504 | 505 | 507 | 511;
export type HTTPStatusCodes = HTTPStatusCode1xx | HTTPStatusCode2xx | HTTPStatusCode3xx | HTTPStatusCode4xx | HTTPStatusCode5xx;

/**
 * @summary List Workspaces
 */
export type listWorkspacesV1WorkspacesGetResponse200 = {
  data: WorkspacesListRes
  status: 200
}

export type listWorkspacesV1WorkspacesGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type listWorkspacesV1WorkspacesGetResponseSuccess = (listWorkspacesV1WorkspacesGetResponse200) & {
  headers: Headers;
};
export type listWorkspacesV1WorkspacesGetResponseError = (listWorkspacesV1WorkspacesGetResponseDefault) & {
  headers: Headers;
};

export type listWorkspacesV1WorkspacesGetResponse = (listWorkspacesV1WorkspacesGetResponseSuccess | listWorkspacesV1WorkspacesGetResponseError)

export const getListWorkspacesV1WorkspacesGetUrl = (params?: ListWorkspacesV1WorkspacesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/workspaces?${stringifiedParams}` : `/v1/workspaces`
}

export const listWorkspacesV1WorkspacesGet = async (params?: ListWorkspacesV1WorkspacesGetParams, options?: RequestInit): Promise<listWorkspacesV1WorkspacesGetResponse> => {
  
  const res = await fetch(getListWorkspacesV1WorkspacesGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listWorkspacesV1WorkspacesGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listWorkspacesV1WorkspacesGetResponse
}



/**
 * @summary Create Workspace
 */
export type createWorkspaceV1WorkspacesPostResponse201 = {
  data: WorkspaceRes
  status: 201
}

export type createWorkspaceV1WorkspacesPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 201>
}
    
export type createWorkspaceV1WorkspacesPostResponseSuccess = (createWorkspaceV1WorkspacesPostResponse201) & {
  headers: Headers;
};
export type createWorkspaceV1WorkspacesPostResponseError = (createWorkspaceV1WorkspacesPostResponseDefault) & {
  headers: Headers;
};

export type createWorkspaceV1WorkspacesPostResponse = (createWorkspaceV1WorkspacesPostResponseSuccess | createWorkspaceV1WorkspacesPostResponseError)

export const getCreateWorkspaceV1WorkspacesPostUrl = () => {


  

  return `/v1/workspaces`
}

export const createWorkspaceV1WorkspacesPost = async (createWorkspaceReq: CreateWorkspaceReq, options?: RequestInit): Promise<createWorkspaceV1WorkspacesPostResponse> => {
  
  const res = await fetch(getCreateWorkspaceV1WorkspacesPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createWorkspaceReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createWorkspaceV1WorkspacesPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createWorkspaceV1WorkspacesPostResponse
}



/**
 * @summary Get Workspace
 */
export type getWorkspaceV1WorkspacesWorkspaceIdGetResponse200 = {
  data: WorkspaceRes
  status: 200
}

export type getWorkspaceV1WorkspacesWorkspaceIdGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type getWorkspaceV1WorkspacesWorkspaceIdGetResponseSuccess = (getWorkspaceV1WorkspacesWorkspaceIdGetResponse200) & {
  headers: Headers;
};
export type getWorkspaceV1WorkspacesWorkspaceIdGetResponseError = (getWorkspaceV1WorkspacesWorkspaceIdGetResponseDefault) & {
  headers: Headers;
};

export type getWorkspaceV1WorkspacesWorkspaceIdGetResponse = (getWorkspaceV1WorkspacesWorkspaceIdGetResponseSuccess | getWorkspaceV1WorkspacesWorkspaceIdGetResponseError)

export const getGetWorkspaceV1WorkspacesWorkspaceIdGetUrl = (workspaceId: string,) => {


  

  return `/v1/workspaces/${workspaceId}`
}

export const getWorkspaceV1WorkspacesWorkspaceIdGet = async (workspaceId: string, options?: RequestInit): Promise<getWorkspaceV1WorkspacesWorkspaceIdGetResponse> => {
  
  const res = await fetch(getGetWorkspaceV1WorkspacesWorkspaceIdGetUrl(workspaceId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getWorkspaceV1WorkspacesWorkspaceIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getWorkspaceV1WorkspacesWorkspaceIdGetResponse
}



/**
 * @summary Update Workspace
 */
export type updateWorkspaceV1WorkspacesWorkspaceIdPatchResponse200 = {
  data: WorkspaceRes
  status: 200
}

export type updateWorkspaceV1WorkspacesWorkspaceIdPatchResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type updateWorkspaceV1WorkspacesWorkspaceIdPatchResponseSuccess = (updateWorkspaceV1WorkspacesWorkspaceIdPatchResponse200) & {
  headers: Headers;
};
export type updateWorkspaceV1WorkspacesWorkspaceIdPatchResponseError = (updateWorkspaceV1WorkspacesWorkspaceIdPatchResponseDefault) & {
  headers: Headers;
};

export type updateWorkspaceV1WorkspacesWorkspaceIdPatchResponse = (updateWorkspaceV1WorkspacesWorkspaceIdPatchResponseSuccess | updateWorkspaceV1WorkspacesWorkspaceIdPatchResponseError)

export const getUpdateWorkspaceV1WorkspacesWorkspaceIdPatchUrl = (workspaceId: string,) => {


  

  return `/v1/workspaces/${workspaceId}`
}

export const updateWorkspaceV1WorkspacesWorkspaceIdPatch = async (workspaceId: string,
    updateWorkspaceReq: UpdateWorkspaceReq, options?: RequestInit): Promise<updateWorkspaceV1WorkspacesWorkspaceIdPatchResponse> => {
  
  const res = await fetch(getUpdateWorkspaceV1WorkspacesWorkspaceIdPatchUrl(workspaceId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateWorkspaceReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateWorkspaceV1WorkspacesWorkspaceIdPatchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateWorkspaceV1WorkspacesWorkspaceIdPatchResponse
}



/**
 * @summary Archive Workspace
 */
export type archiveWorkspaceV1WorkspacesWorkspaceIdDeleteResponse200 = {
  data: ArchiveWorkspaceRes
  status: 200
}

export type archiveWorkspaceV1WorkspacesWorkspaceIdDeleteResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type archiveWorkspaceV1WorkspacesWorkspaceIdDeleteResponseSuccess = (archiveWorkspaceV1WorkspacesWorkspaceIdDeleteResponse200) & {
  headers: Headers;
};
export type archiveWorkspaceV1WorkspacesWorkspaceIdDeleteResponseError = (archiveWorkspaceV1WorkspacesWorkspaceIdDeleteResponseDefault) & {
  headers: Headers;
};

export type archiveWorkspaceV1WorkspacesWorkspaceIdDeleteResponse = (archiveWorkspaceV1WorkspacesWorkspaceIdDeleteResponseSuccess | archiveWorkspaceV1WorkspacesWorkspaceIdDeleteResponseError)

export const getArchiveWorkspaceV1WorkspacesWorkspaceIdDeleteUrl = (workspaceId: string,) => {


  

  return `/v1/workspaces/${workspaceId}`
}

export const archiveWorkspaceV1WorkspacesWorkspaceIdDelete = async (workspaceId: string, options?: RequestInit): Promise<archiveWorkspaceV1WorkspacesWorkspaceIdDeleteResponse> => {
  
  const res = await fetch(getArchiveWorkspaceV1WorkspacesWorkspaceIdDeleteUrl(workspaceId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: archiveWorkspaceV1WorkspacesWorkspaceIdDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as archiveWorkspaceV1WorkspacesWorkspaceIdDeleteResponse
}



/**
 * @summary Publish Workspace
 */
export type publishWorkspaceV1WorkspacesWorkspaceIdPublishPostResponse200 = {
  data: WorkspaceRes
  status: 200
}

export type publishWorkspaceV1WorkspacesWorkspaceIdPublishPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type publishWorkspaceV1WorkspacesWorkspaceIdPublishPostResponseSuccess = (publishWorkspaceV1WorkspacesWorkspaceIdPublishPostResponse200) & {
  headers: Headers;
};
export type publishWorkspaceV1WorkspacesWorkspaceIdPublishPostResponseError = (publishWorkspaceV1WorkspacesWorkspaceIdPublishPostResponseDefault) & {
  headers: Headers;
};

export type publishWorkspaceV1WorkspacesWorkspaceIdPublishPostResponse = (publishWorkspaceV1WorkspacesWorkspaceIdPublishPostResponseSuccess | publishWorkspaceV1WorkspacesWorkspaceIdPublishPostResponseError)

export const getPublishWorkspaceV1WorkspacesWorkspaceIdPublishPostUrl = (workspaceId: string,) => {


  

  return `/v1/workspaces/${workspaceId}/publish`
}

export const publishWorkspaceV1WorkspacesWorkspaceIdPublishPost = async (workspaceId: string, options?: RequestInit): Promise<publishWorkspaceV1WorkspacesWorkspaceIdPublishPostResponse> => {
  
  const res = await fetch(getPublishWorkspaceV1WorkspacesWorkspaceIdPublishPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: publishWorkspaceV1WorkspacesWorkspaceIdPublishPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as publishWorkspaceV1WorkspacesWorkspaceIdPublishPostResponse
}



/**
 * @summary Share Workspace
 */
export type shareWorkspaceV1WorkspacesWorkspaceIdSharePostResponse200 = {
  data: WorkspaceRes
  status: 200
}

export type shareWorkspaceV1WorkspacesWorkspaceIdSharePostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type shareWorkspaceV1WorkspacesWorkspaceIdSharePostResponseSuccess = (shareWorkspaceV1WorkspacesWorkspaceIdSharePostResponse200) & {
  headers: Headers;
};
export type shareWorkspaceV1WorkspacesWorkspaceIdSharePostResponseError = (shareWorkspaceV1WorkspacesWorkspaceIdSharePostResponseDefault) & {
  headers: Headers;
};

export type shareWorkspaceV1WorkspacesWorkspaceIdSharePostResponse = (shareWorkspaceV1WorkspacesWorkspaceIdSharePostResponseSuccess | shareWorkspaceV1WorkspacesWorkspaceIdSharePostResponseError)

export const getShareWorkspaceV1WorkspacesWorkspaceIdSharePostUrl = (workspaceId: string,) => {


  

  return `/v1/workspaces/${workspaceId}/share`
}

export const shareWorkspaceV1WorkspacesWorkspaceIdSharePost = async (workspaceId: string,
    shareWorkspaceReq: ShareWorkspaceReq, options?: RequestInit): Promise<shareWorkspaceV1WorkspacesWorkspaceIdSharePostResponse> => {
  
  const res = await fetch(getShareWorkspaceV1WorkspacesWorkspaceIdSharePostUrl(workspaceId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      shareWorkspaceReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: shareWorkspaceV1WorkspacesWorkspaceIdSharePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as shareWorkspaceV1WorkspacesWorkspaceIdSharePostResponse
}



/**
 * @summary Archive Workspace Action
 */
export type archiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostResponse200 = {
  data: ArchiveWorkspaceRes
  status: 200
}

export type archiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type archiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostResponseSuccess = (archiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostResponse200) & {
  headers: Headers;
};
export type archiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostResponseError = (archiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostResponseDefault) & {
  headers: Headers;
};

export type archiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostResponse = (archiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostResponseSuccess | archiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostResponseError)

export const getArchiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostUrl = (workspaceId: string,) => {


  

  return `/v1/workspaces/${workspaceId}/archive`
}

export const archiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePost = async (workspaceId: string, options?: RequestInit): Promise<archiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostResponse> => {
  
  const res = await fetch(getArchiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostUrl(workspaceId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: archiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as archiveWorkspaceActionV1WorkspacesWorkspaceIdArchivePostResponse
}



/**
 * @deprecated
 * @summary List Documents
 */
export type listDocumentsV1DocumentsGetResponse200 = {
  data: DocumentsListRes
  status: 200
}

export type listDocumentsV1DocumentsGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type listDocumentsV1DocumentsGetResponseSuccess = (listDocumentsV1DocumentsGetResponse200) & {
  headers: Headers;
};
export type listDocumentsV1DocumentsGetResponseError = (listDocumentsV1DocumentsGetResponseDefault) & {
  headers: Headers;
};

export type listDocumentsV1DocumentsGetResponse = (listDocumentsV1DocumentsGetResponseSuccess | listDocumentsV1DocumentsGetResponseError)

export const getListDocumentsV1DocumentsGetUrl = (params?: ListDocumentsV1DocumentsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/documents?${stringifiedParams}` : `/v1/documents`
}

export const listDocumentsV1DocumentsGet = async (params?: ListDocumentsV1DocumentsGetParams, options?: RequestInit): Promise<listDocumentsV1DocumentsGetResponse> => {
  
  const res = await fetch(getListDocumentsV1DocumentsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listDocumentsV1DocumentsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listDocumentsV1DocumentsGetResponse
}



/**
 * @deprecated
 * @summary Get Document
 */
export type getDocumentV1DocumentsDocumentIdGetResponse200 = {
  data: DocumentDetailRes
  status: 200
}

export type getDocumentV1DocumentsDocumentIdGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type getDocumentV1DocumentsDocumentIdGetResponseSuccess = (getDocumentV1DocumentsDocumentIdGetResponse200) & {
  headers: Headers;
};
export type getDocumentV1DocumentsDocumentIdGetResponseError = (getDocumentV1DocumentsDocumentIdGetResponseDefault) & {
  headers: Headers;
};

export type getDocumentV1DocumentsDocumentIdGetResponse = (getDocumentV1DocumentsDocumentIdGetResponseSuccess | getDocumentV1DocumentsDocumentIdGetResponseError)

export const getGetDocumentV1DocumentsDocumentIdGetUrl = (documentId: string,
    params?: GetDocumentV1DocumentsDocumentIdGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/documents/${documentId}?${stringifiedParams}` : `/v1/documents/${documentId}`
}

export const getDocumentV1DocumentsDocumentIdGet = async (documentId: string,
    params?: GetDocumentV1DocumentsDocumentIdGetParams, options?: RequestInit): Promise<getDocumentV1DocumentsDocumentIdGetResponse> => {
  
  const res = await fetch(getGetDocumentV1DocumentsDocumentIdGetUrl(documentId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getDocumentV1DocumentsDocumentIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getDocumentV1DocumentsDocumentIdGetResponse
}



/**
 * @deprecated
 * @summary Delete Document
 */
export type deleteDocumentV1DocumentsDocumentIdDeleteResponse200 = {
  data: DeleteDocumentRes
  status: 200
}

export type deleteDocumentV1DocumentsDocumentIdDeleteResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type deleteDocumentV1DocumentsDocumentIdDeleteResponseSuccess = (deleteDocumentV1DocumentsDocumentIdDeleteResponse200) & {
  headers: Headers;
};
export type deleteDocumentV1DocumentsDocumentIdDeleteResponseError = (deleteDocumentV1DocumentsDocumentIdDeleteResponseDefault) & {
  headers: Headers;
};

export type deleteDocumentV1DocumentsDocumentIdDeleteResponse = (deleteDocumentV1DocumentsDocumentIdDeleteResponseSuccess | deleteDocumentV1DocumentsDocumentIdDeleteResponseError)

export const getDeleteDocumentV1DocumentsDocumentIdDeleteUrl = (documentId: string,
    params?: DeleteDocumentV1DocumentsDocumentIdDeleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/documents/${documentId}?${stringifiedParams}` : `/v1/documents/${documentId}`
}

export const deleteDocumentV1DocumentsDocumentIdDelete = async (documentId: string,
    params?: DeleteDocumentV1DocumentsDocumentIdDeleteParams, options?: RequestInit): Promise<deleteDocumentV1DocumentsDocumentIdDeleteResponse> => {
  
  const res = await fetch(getDeleteDocumentV1DocumentsDocumentIdDeleteUrl(documentId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteDocumentV1DocumentsDocumentIdDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteDocumentV1DocumentsDocumentIdDeleteResponse
}



/**
 * @deprecated
 * @summary Upload Document
 */
export type uploadDocumentV1DocumentsUploadPostResponse200 = {
  data: UploadDocumentRes
  status: 200
}

export type uploadDocumentV1DocumentsUploadPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type uploadDocumentV1DocumentsUploadPostResponseSuccess = (uploadDocumentV1DocumentsUploadPostResponse200) & {
  headers: Headers;
};
export type uploadDocumentV1DocumentsUploadPostResponseError = (uploadDocumentV1DocumentsUploadPostResponseDefault) & {
  headers: Headers;
};

export type uploadDocumentV1DocumentsUploadPostResponse = (uploadDocumentV1DocumentsUploadPostResponseSuccess | uploadDocumentV1DocumentsUploadPostResponseError)

export const getUploadDocumentV1DocumentsUploadPostUrl = (params?: UploadDocumentV1DocumentsUploadPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/documents/upload?${stringifiedParams}` : `/v1/documents/upload`
}

export const uploadDocumentV1DocumentsUploadPost = async (bodyUploadDocumentV1DocumentsUploadPost: BodyUploadDocumentV1DocumentsUploadPost,
    params?: UploadDocumentV1DocumentsUploadPostParams, options?: RequestInit): Promise<uploadDocumentV1DocumentsUploadPostResponse> => {
    const formData = new FormData();
formData.append(`file`, bodyUploadDocumentV1DocumentsUploadPost.file)
if(bodyUploadDocumentV1DocumentsUploadPost.title !== undefined && bodyUploadDocumentV1DocumentsUploadPost.title !== null) {
 formData.append(`title`, bodyUploadDocumentV1DocumentsUploadPost.title)
 }
if(bodyUploadDocumentV1DocumentsUploadPost.source !== undefined && bodyUploadDocumentV1DocumentsUploadPost.source !== null) {
 formData.append(`source`, bodyUploadDocumentV1DocumentsUploadPost.source)
 }
if(bodyUploadDocumentV1DocumentsUploadPost.metadata !== undefined && bodyUploadDocumentV1DocumentsUploadPost.metadata !== null) {
 formData.append(`metadata`, bodyUploadDocumentV1DocumentsUploadPost.metadata)
 }

  const res = await fetch(getUploadDocumentV1DocumentsUploadPostUrl(params),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: uploadDocumentV1DocumentsUploadPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as uploadDocumentV1DocumentsUploadPostResponse
}



/**
 * @deprecated
 * @summary Reprocess Document
 */
export type reprocessDocumentV1DocumentsDocumentIdReprocessPostResponse202 = {
  data: ReprocessDocumentRes
  status: 202
}

export type reprocessDocumentV1DocumentsDocumentIdReprocessPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 202>
}
    
export type reprocessDocumentV1DocumentsDocumentIdReprocessPostResponseSuccess = (reprocessDocumentV1DocumentsDocumentIdReprocessPostResponse202) & {
  headers: Headers;
};
export type reprocessDocumentV1DocumentsDocumentIdReprocessPostResponseError = (reprocessDocumentV1DocumentsDocumentIdReprocessPostResponseDefault) & {
  headers: Headers;
};

export type reprocessDocumentV1DocumentsDocumentIdReprocessPostResponse = (reprocessDocumentV1DocumentsDocumentIdReprocessPostResponseSuccess | reprocessDocumentV1DocumentsDocumentIdReprocessPostResponseError)

export const getReprocessDocumentV1DocumentsDocumentIdReprocessPostUrl = (documentId: string,
    params?: ReprocessDocumentV1DocumentsDocumentIdReprocessPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/documents/${documentId}/reprocess?${stringifiedParams}` : `/v1/documents/${documentId}/reprocess`
}

export const reprocessDocumentV1DocumentsDocumentIdReprocessPost = async (documentId: string,
    params?: ReprocessDocumentV1DocumentsDocumentIdReprocessPostParams, options?: RequestInit): Promise<reprocessDocumentV1DocumentsDocumentIdReprocessPostResponse> => {
  
  const res = await fetch(getReprocessDocumentV1DocumentsDocumentIdReprocessPostUrl(documentId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: reprocessDocumentV1DocumentsDocumentIdReprocessPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as reprocessDocumentV1DocumentsDocumentIdReprocessPostResponse
}



/**
 * @deprecated
 * @summary Ingest Text
 */
export type ingestTextV1IngestTextPostResponse200 = {
  data: IngestTextRes
  status: 200
}

export type ingestTextV1IngestTextPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type ingestTextV1IngestTextPostResponseSuccess = (ingestTextV1IngestTextPostResponse200) & {
  headers: Headers;
};
export type ingestTextV1IngestTextPostResponseError = (ingestTextV1IngestTextPostResponseDefault) & {
  headers: Headers;
};

export type ingestTextV1IngestTextPostResponse = (ingestTextV1IngestTextPostResponseSuccess | ingestTextV1IngestTextPostResponseError)

export const getIngestTextV1IngestTextPostUrl = (params?: IngestTextV1IngestTextPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/ingest/text?${stringifiedParams}` : `/v1/ingest/text`
}

export const ingestTextV1IngestTextPost = async (ingestTextReq: IngestTextReq,
    params?: IngestTextV1IngestTextPostParams, options?: RequestInit): Promise<ingestTextV1IngestTextPostResponse> => {
  
  const res = await fetch(getIngestTextV1IngestTextPostUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestTextReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ingestTextV1IngestTextPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ingestTextV1IngestTextPostResponse
}



/**
 * Ingest multiple documents in a single request.

Processes up to 10 documents sequentially.
Returns results for all successfully ingested documents.
 * @deprecated
 * @summary Ingest Batch
 */
export type ingestBatchV1IngestBatchPostResponse200 = {
  data: IngestBatchRes
  status: 200
}

export type ingestBatchV1IngestBatchPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type ingestBatchV1IngestBatchPostResponseSuccess = (ingestBatchV1IngestBatchPostResponse200) & {
  headers: Headers;
};
export type ingestBatchV1IngestBatchPostResponseError = (ingestBatchV1IngestBatchPostResponseDefault) & {
  headers: Headers;
};

export type ingestBatchV1IngestBatchPostResponse = (ingestBatchV1IngestBatchPostResponseSuccess | ingestBatchV1IngestBatchPostResponseError)

export const getIngestBatchV1IngestBatchPostUrl = (params?: IngestBatchV1IngestBatchPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/ingest/batch?${stringifiedParams}` : `/v1/ingest/batch`
}

export const ingestBatchV1IngestBatchPost = async (ingestBatchReq: IngestBatchReq,
    params?: IngestBatchV1IngestBatchPostParams, options?: RequestInit): Promise<ingestBatchV1IngestBatchPostResponse> => {
  
  const res = await fetch(getIngestBatchV1IngestBatchPostUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestBatchReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ingestBatchV1IngestBatchPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ingestBatchV1IngestBatchPostResponse
}



/**
 * @deprecated
 * @summary Query
 */
export type queryV1QueryPostResponse200 = {
  data: QueryRes
  status: 200
}

export type queryV1QueryPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type queryV1QueryPostResponseSuccess = (queryV1QueryPostResponse200) & {
  headers: Headers;
};
export type queryV1QueryPostResponseError = (queryV1QueryPostResponseDefault) & {
  headers: Headers;
};

export type queryV1QueryPostResponse = (queryV1QueryPostResponseSuccess | queryV1QueryPostResponseError)

export const getQueryV1QueryPostUrl = (params?: QueryV1QueryPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/query?${stringifiedParams}` : `/v1/query`
}

export const queryV1QueryPost = async (queryReq: QueryReq,
    params?: QueryV1QueryPostParams, options?: RequestInit): Promise<queryV1QueryPostResponse> => {
  
  const res = await fetch(getQueryV1QueryPostUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: queryV1QueryPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as queryV1QueryPostResponse
}



/**
 * R: RAG endpoint using Clean Architecture (Use Case pattern).

This endpoint demonstrates the architecture improvement:
- Business logic in use case (testable, framework-independent)
- Dependency injection via FastAPI Depends
- Separation of concerns (HTTP ‚Üî Business Logic)

Uses the same query contract as /query with a generation step.
Set use_mmr=true for diverse results (reduces redundant chunks).
 * @deprecated
 * @summary Ask
 */
export type askV1AskPostResponse200 = {
  data: AskRes
  status: 200
}

export type askV1AskPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type askV1AskPostResponseSuccess = (askV1AskPostResponse200) & {
  headers: Headers;
};
export type askV1AskPostResponseError = (askV1AskPostResponseDefault) & {
  headers: Headers;
};

export type askV1AskPostResponse = (askV1AskPostResponseSuccess | askV1AskPostResponseError)

export const getAskV1AskPostUrl = (params?: AskV1AskPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/ask?${stringifiedParams}` : `/v1/ask`
}

export const askV1AskPost = async (queryReq: QueryReq,
    params?: AskV1AskPostParams, options?: RequestInit): Promise<askV1AskPostResponse> => {
  
  const res = await fetch(getAskV1AskPostUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: askV1AskPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as askV1AskPostResponse
}



/**
 * R: Streaming RAG endpoint using Server-Sent Events.

Returns tokens as they are generated by the LLM for better UX.
Uses the same query contract as /ask but streams the response.

SSE Events:
- sources: Initial event with retrieved chunks
- token: Individual tokens as generated
- done: Final event with complete answer
- error: Error event if generation fails
 * @deprecated
 * @summary Ask Stream
 */
export type askStreamV1AskStreamPostResponse200 = {
  data: unknown
  status: 200
}

export type askStreamV1AskStreamPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type askStreamV1AskStreamPostResponseSuccess = (askStreamV1AskStreamPostResponse200) & {
  headers: Headers;
};
export type askStreamV1AskStreamPostResponseError = (askStreamV1AskStreamPostResponseDefault) & {
  headers: Headers;
};

export type askStreamV1AskStreamPostResponse = (askStreamV1AskStreamPostResponseSuccess | askStreamV1AskStreamPostResponseError)

export const getAskStreamV1AskStreamPostUrl = (params?: AskStreamV1AskStreamPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/ask/stream?${stringifiedParams}` : `/v1/ask/stream`
}

export const askStreamV1AskStreamPost = async (queryReq: QueryReq,
    params?: AskStreamV1AskStreamPostParams, options?: RequestInit): Promise<askStreamV1AskStreamPostResponse> => {
  
  const res = await fetch(getAskStreamV1AskStreamPostUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: askStreamV1AskStreamPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as askStreamV1AskStreamPostResponse
}



/**
 * @summary List Workspace Documents
 */
export type listWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetResponse200 = {
  data: DocumentsListRes
  status: 200
}

export type listWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type listWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetResponseSuccess = (listWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetResponse200) & {
  headers: Headers;
};
export type listWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetResponseError = (listWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetResponseDefault) & {
  headers: Headers;
};

export type listWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetResponse = (listWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetResponseSuccess | listWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetResponseError)

export const getListWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetUrl = (workspaceId: string,
    params?: ListWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/workspaces/${workspaceId}/documents?${stringifiedParams}` : `/v1/workspaces/${workspaceId}/documents`
}

export const listWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGet = async (workspaceId: string,
    params?: ListWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetParams, options?: RequestInit): Promise<listWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetResponse> => {
  
  const res = await fetch(getListWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetUrl(workspaceId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listWorkspaceDocumentsV1WorkspacesWorkspaceIdDocumentsGetResponse
}



/**
 * @summary Get Workspace Document
 */
export type getWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponse200 = {
  data: DocumentDetailRes
  status: 200
}

export type getWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type getWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponseSuccess = (getWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponse200) & {
  headers: Headers;
};
export type getWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponseError = (getWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponseDefault) & {
  headers: Headers;
};

export type getWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponse = (getWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponseSuccess | getWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponseError)

export const getGetWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetUrl = (workspaceId: string,
    documentId: string,) => {


  

  return `/v1/workspaces/${workspaceId}/documents/${documentId}`
}

export const getWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGet = async (workspaceId: string,
    documentId: string, options?: RequestInit): Promise<getWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponse> => {
  
  const res = await fetch(getGetWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetUrl(workspaceId,documentId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponse
}



/**
 * @summary Delete Workspace Document
 */
export type deleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponse200 = {
  data: DeleteDocumentRes
  status: 200
}

export type deleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type deleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponseSuccess = (deleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponse200) & {
  headers: Headers;
};
export type deleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponseError = (deleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponseDefault) & {
  headers: Headers;
};

export type deleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponse = (deleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponseSuccess | deleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponseError)

export const getDeleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteUrl = (workspaceId: string,
    documentId: string,) => {


  

  return `/v1/workspaces/${workspaceId}/documents/${documentId}`
}

export const deleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDelete = async (workspaceId: string,
    documentId: string, options?: RequestInit): Promise<deleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponse> => {
  
  const res = await fetch(getDeleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteUrl(workspaceId,documentId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponse
}



/**
 * @summary Upload Workspace Document
 */
export type uploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostResponse200 = {
  data: UploadDocumentRes
  status: 200
}

export type uploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type uploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostResponseSuccess = (uploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostResponse200) & {
  headers: Headers;
};
export type uploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostResponseError = (uploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostResponseDefault) & {
  headers: Headers;
};

export type uploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostResponse = (uploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostResponseSuccess | uploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostResponseError)

export const getUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostUrl = (workspaceId: string,) => {


  

  return `/v1/workspaces/${workspaceId}/documents/upload`
}

export const uploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost = async (workspaceId: string,
    bodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost: BodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost, options?: RequestInit): Promise<uploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostResponse> => {
    const formData = new FormData();
formData.append(`file`, bodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost.file)
if(bodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost.title !== undefined && bodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost.title !== null) {
 formData.append(`title`, bodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost.title)
 }
if(bodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost.source !== undefined && bodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost.source !== null) {
 formData.append(`source`, bodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost.source)
 }
if(bodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost.metadata !== undefined && bodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost.metadata !== null) {
 formData.append(`metadata`, bodyUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPost.metadata)
 }

  const res = await fetch(getUploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: uploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as uploadWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsUploadPostResponse
}



/**
 * @summary Reprocess Workspace Document
 */
export type reprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponse202 = {
  data: ReprocessDocumentRes
  status: 202
}

export type reprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 202>
}
    
export type reprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponseSuccess = (reprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponse202) & {
  headers: Headers;
};
export type reprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponseError = (reprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponseDefault) & {
  headers: Headers;
};

export type reprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponse = (reprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponseSuccess | reprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponseError)

export const getReprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostUrl = (workspaceId: string,
    documentId: string,) => {


  

  return `/v1/workspaces/${workspaceId}/documents/${documentId}/reprocess`
}

export const reprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPost = async (workspaceId: string,
    documentId: string, options?: RequestInit): Promise<reprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponse> => {
  
  const res = await fetch(getReprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostUrl(workspaceId,documentId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: reprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as reprocessWorkspaceDocumentV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponse
}



/**
 * @summary Ingest Workspace Text
 */
export type ingestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostResponse200 = {
  data: IngestTextRes
  status: 200
}

export type ingestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type ingestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostResponseSuccess = (ingestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostResponse200) & {
  headers: Headers;
};
export type ingestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostResponseError = (ingestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostResponseDefault) & {
  headers: Headers;
};

export type ingestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostResponse = (ingestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostResponseSuccess | ingestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostResponseError)

export const getIngestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostUrl = (workspaceId: string,) => {


  

  return `/v1/workspaces/${workspaceId}/ingest/text`
}

export const ingestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPost = async (workspaceId: string,
    ingestTextReq: IngestTextReq, options?: RequestInit): Promise<ingestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostResponse> => {
  
  const res = await fetch(getIngestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestTextReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ingestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ingestWorkspaceTextV1WorkspacesWorkspaceIdIngestTextPostResponse
}



/**
 * @summary Ingest Workspace Batch
 */
export type ingestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostResponse200 = {
  data: IngestBatchRes
  status: 200
}

export type ingestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type ingestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostResponseSuccess = (ingestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostResponse200) & {
  headers: Headers;
};
export type ingestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostResponseError = (ingestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostResponseDefault) & {
  headers: Headers;
};

export type ingestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostResponse = (ingestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostResponseSuccess | ingestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostResponseError)

export const getIngestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostUrl = (workspaceId: string,) => {


  

  return `/v1/workspaces/${workspaceId}/ingest/batch`
}

export const ingestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPost = async (workspaceId: string,
    ingestBatchReq: IngestBatchReq, options?: RequestInit): Promise<ingestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostResponse> => {
  
  const res = await fetch(getIngestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestBatchReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ingestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ingestWorkspaceBatchV1WorkspacesWorkspaceIdIngestBatchPostResponse
}



/**
 * @summary Query Workspace
 */
export type queryWorkspaceV1WorkspacesWorkspaceIdQueryPostResponse200 = {
  data: QueryRes
  status: 200
}

export type queryWorkspaceV1WorkspacesWorkspaceIdQueryPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type queryWorkspaceV1WorkspacesWorkspaceIdQueryPostResponseSuccess = (queryWorkspaceV1WorkspacesWorkspaceIdQueryPostResponse200) & {
  headers: Headers;
};
export type queryWorkspaceV1WorkspacesWorkspaceIdQueryPostResponseError = (queryWorkspaceV1WorkspacesWorkspaceIdQueryPostResponseDefault) & {
  headers: Headers;
};

export type queryWorkspaceV1WorkspacesWorkspaceIdQueryPostResponse = (queryWorkspaceV1WorkspacesWorkspaceIdQueryPostResponseSuccess | queryWorkspaceV1WorkspacesWorkspaceIdQueryPostResponseError)

export const getQueryWorkspaceV1WorkspacesWorkspaceIdQueryPostUrl = (workspaceId: string,) => {


  

  return `/v1/workspaces/${workspaceId}/query`
}

export const queryWorkspaceV1WorkspacesWorkspaceIdQueryPost = async (workspaceId: string,
    queryReq: QueryReq, options?: RequestInit): Promise<queryWorkspaceV1WorkspacesWorkspaceIdQueryPostResponse> => {
  
  const res = await fetch(getQueryWorkspaceV1WorkspacesWorkspaceIdQueryPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: queryWorkspaceV1WorkspacesWorkspaceIdQueryPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as queryWorkspaceV1WorkspacesWorkspaceIdQueryPostResponse
}



/**
 * @summary Ask Workspace
 */
export type askWorkspaceV1WorkspacesWorkspaceIdAskPostResponse200 = {
  data: AskRes
  status: 200
}

export type askWorkspaceV1WorkspacesWorkspaceIdAskPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type askWorkspaceV1WorkspacesWorkspaceIdAskPostResponseSuccess = (askWorkspaceV1WorkspacesWorkspaceIdAskPostResponse200) & {
  headers: Headers;
};
export type askWorkspaceV1WorkspacesWorkspaceIdAskPostResponseError = (askWorkspaceV1WorkspacesWorkspaceIdAskPostResponseDefault) & {
  headers: Headers;
};

export type askWorkspaceV1WorkspacesWorkspaceIdAskPostResponse = (askWorkspaceV1WorkspacesWorkspaceIdAskPostResponseSuccess | askWorkspaceV1WorkspacesWorkspaceIdAskPostResponseError)

export const getAskWorkspaceV1WorkspacesWorkspaceIdAskPostUrl = (workspaceId: string,) => {


  

  return `/v1/workspaces/${workspaceId}/ask`
}

export const askWorkspaceV1WorkspacesWorkspaceIdAskPost = async (workspaceId: string,
    queryReq: QueryReq, options?: RequestInit): Promise<askWorkspaceV1WorkspacesWorkspaceIdAskPostResponse> => {
  
  const res = await fetch(getAskWorkspaceV1WorkspacesWorkspaceIdAskPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: askWorkspaceV1WorkspacesWorkspaceIdAskPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as askWorkspaceV1WorkspacesWorkspaceIdAskPostResponse
}



/**
 * @summary Ask Workspace Stream
 */
export type askWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostResponse200 = {
  data: unknown
  status: 200
}

export type askWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type askWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostResponseSuccess = (askWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostResponse200) & {
  headers: Headers;
};
export type askWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostResponseError = (askWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostResponseDefault) & {
  headers: Headers;
};

export type askWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostResponse = (askWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostResponseSuccess | askWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostResponseError)

export const getAskWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostUrl = (workspaceId: string,) => {


  

  return `/v1/workspaces/${workspaceId}/ask/stream`
}

export const askWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPost = async (workspaceId: string,
    queryReq: QueryReq, options?: RequestInit): Promise<askWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostResponse> => {
  
  const res = await fetch(getAskWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: askWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as askWorkspaceStreamV1WorkspacesWorkspaceIdAskStreamPostResponse
}



/**
 * @summary Login
 */
export type loginAuthLoginPostResponse200 = {
  data: LoginResponse
  status: 200
}

export type loginAuthLoginPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type loginAuthLoginPostResponseSuccess = (loginAuthLoginPostResponse200) & {
  headers: Headers;
};
export type loginAuthLoginPostResponseError = (loginAuthLoginPostResponseDefault) & {
  headers: Headers;
};

export type loginAuthLoginPostResponse = (loginAuthLoginPostResponseSuccess | loginAuthLoginPostResponseError)

export const getLoginAuthLoginPostUrl = () => {


  

  return `/auth/login`
}

export const loginAuthLoginPost = async (loginRequest: LoginRequest, options?: RequestInit): Promise<loginAuthLoginPostResponse> => {
  
  const res = await fetch(getLoginAuthLoginPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: loginAuthLoginPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as loginAuthLoginPostResponse
}



/**
 * @summary Me
 */
export type meAuthMeGetResponse200 = {
  data: UserResponse
  status: 200
}

export type meAuthMeGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type meAuthMeGetResponseSuccess = (meAuthMeGetResponse200) & {
  headers: Headers;
};
export type meAuthMeGetResponseError = (meAuthMeGetResponseDefault) & {
  headers: Headers;
};

export type meAuthMeGetResponse = (meAuthMeGetResponseSuccess | meAuthMeGetResponseError)

export const getMeAuthMeGetUrl = () => {


  

  return `/auth/me`
}

export const meAuthMeGet = async ( options?: RequestInit): Promise<meAuthMeGetResponse> => {
  
  const res = await fetch(getMeAuthMeGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: meAuthMeGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as meAuthMeGetResponse
}



/**
 * @summary Logout
 */
export type logoutAuthLogoutPostResponse200 = {
  data: unknown
  status: 200
}

export type logoutAuthLogoutPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type logoutAuthLogoutPostResponseSuccess = (logoutAuthLogoutPostResponse200) & {
  headers: Headers;
};
export type logoutAuthLogoutPostResponseError = (logoutAuthLogoutPostResponseDefault) & {
  headers: Headers;
};

export type logoutAuthLogoutPostResponse = (logoutAuthLogoutPostResponseSuccess | logoutAuthLogoutPostResponseError)

export const getLogoutAuthLogoutPostUrl = () => {


  

  return `/auth/logout`
}

export const logoutAuthLogoutPost = async ( options?: RequestInit): Promise<logoutAuthLogoutPostResponse> => {
  
  const res = await fetch(getLogoutAuthLogoutPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: logoutAuthLogoutPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as logoutAuthLogoutPostResponse
}



/**
 * @summary List Users Admin
 */
export type listUsersAdminAuthUsersGetResponse200 = {
  data: UsersListResponse
  status: 200
}

export type listUsersAdminAuthUsersGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type listUsersAdminAuthUsersGetResponseSuccess = (listUsersAdminAuthUsersGetResponse200) & {
  headers: Headers;
};
export type listUsersAdminAuthUsersGetResponseError = (listUsersAdminAuthUsersGetResponseDefault) & {
  headers: Headers;
};

export type listUsersAdminAuthUsersGetResponse = (listUsersAdminAuthUsersGetResponseSuccess | listUsersAdminAuthUsersGetResponseError)

export const getListUsersAdminAuthUsersGetUrl = () => {


  

  return `/auth/users`
}

export const listUsersAdminAuthUsersGet = async ( options?: RequestInit): Promise<listUsersAdminAuthUsersGetResponse> => {
  
  const res = await fetch(getListUsersAdminAuthUsersGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listUsersAdminAuthUsersGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listUsersAdminAuthUsersGetResponse
}



/**
 * @summary Create User Admin
 */
export type createUserAdminAuthUsersPostResponse201 = {
  data: UserResponse
  status: 201
}

export type createUserAdminAuthUsersPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 201>
}
    
export type createUserAdminAuthUsersPostResponseSuccess = (createUserAdminAuthUsersPostResponse201) & {
  headers: Headers;
};
export type createUserAdminAuthUsersPostResponseError = (createUserAdminAuthUsersPostResponseDefault) & {
  headers: Headers;
};

export type createUserAdminAuthUsersPostResponse = (createUserAdminAuthUsersPostResponseSuccess | createUserAdminAuthUsersPostResponseError)

export const getCreateUserAdminAuthUsersPostUrl = () => {


  

  return `/auth/users`
}

export const createUserAdminAuthUsersPost = async (createUserRequest: CreateUserRequest, options?: RequestInit): Promise<createUserAdminAuthUsersPostResponse> => {
  
  const res = await fetch(getCreateUserAdminAuthUsersPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createUserAdminAuthUsersPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createUserAdminAuthUsersPostResponse
}



/**
 * @summary Disable User Admin
 */
export type disableUserAdminAuthUsersUserIdDisablePostResponse200 = {
  data: UserResponse
  status: 200
}

export type disableUserAdminAuthUsersUserIdDisablePostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type disableUserAdminAuthUsersUserIdDisablePostResponseSuccess = (disableUserAdminAuthUsersUserIdDisablePostResponse200) & {
  headers: Headers;
};
export type disableUserAdminAuthUsersUserIdDisablePostResponseError = (disableUserAdminAuthUsersUserIdDisablePostResponseDefault) & {
  headers: Headers;
};

export type disableUserAdminAuthUsersUserIdDisablePostResponse = (disableUserAdminAuthUsersUserIdDisablePostResponseSuccess | disableUserAdminAuthUsersUserIdDisablePostResponseError)

export const getDisableUserAdminAuthUsersUserIdDisablePostUrl = (userId: string,) => {


  

  return `/auth/users/${userId}/disable`
}

export const disableUserAdminAuthUsersUserIdDisablePost = async (userId: string, options?: RequestInit): Promise<disableUserAdminAuthUsersUserIdDisablePostResponse> => {
  
  const res = await fetch(getDisableUserAdminAuthUsersUserIdDisablePostUrl(userId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: disableUserAdminAuthUsersUserIdDisablePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as disableUserAdminAuthUsersUserIdDisablePostResponse
}



/**
 * @summary Reset Password Admin
 */
export type resetPasswordAdminAuthUsersUserIdResetPasswordPostResponse200 = {
  data: UserResponse
  status: 200
}

export type resetPasswordAdminAuthUsersUserIdResetPasswordPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type resetPasswordAdminAuthUsersUserIdResetPasswordPostResponseSuccess = (resetPasswordAdminAuthUsersUserIdResetPasswordPostResponse200) & {
  headers: Headers;
};
export type resetPasswordAdminAuthUsersUserIdResetPasswordPostResponseError = (resetPasswordAdminAuthUsersUserIdResetPasswordPostResponseDefault) & {
  headers: Headers;
};

export type resetPasswordAdminAuthUsersUserIdResetPasswordPostResponse = (resetPasswordAdminAuthUsersUserIdResetPasswordPostResponseSuccess | resetPasswordAdminAuthUsersUserIdResetPasswordPostResponseError)

export const getResetPasswordAdminAuthUsersUserIdResetPasswordPostUrl = (userId: string,) => {


  

  return `/auth/users/${userId}/reset-password`
}

export const resetPasswordAdminAuthUsersUserIdResetPasswordPost = async (userId: string,
    resetPasswordRequest: ResetPasswordRequest, options?: RequestInit): Promise<resetPasswordAdminAuthUsersUserIdResetPasswordPostResponse> => {
  
  const res = await fetch(getResetPasswordAdminAuthUsersUserIdResetPasswordPostUrl(userId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      resetPasswordRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: resetPasswordAdminAuthUsersUserIdResetPasswordPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as resetPasswordAdminAuthUsersUserIdResetPasswordPostResponse
}



/**
 * @summary List Workspaces
 */
export type listWorkspacesApiV1WorkspacesGetResponse200 = {
  data: WorkspacesListRes
  status: 200
}

export type listWorkspacesApiV1WorkspacesGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type listWorkspacesApiV1WorkspacesGetResponseSuccess = (listWorkspacesApiV1WorkspacesGetResponse200) & {
  headers: Headers;
};
export type listWorkspacesApiV1WorkspacesGetResponseError = (listWorkspacesApiV1WorkspacesGetResponseDefault) & {
  headers: Headers;
};

export type listWorkspacesApiV1WorkspacesGetResponse = (listWorkspacesApiV1WorkspacesGetResponseSuccess | listWorkspacesApiV1WorkspacesGetResponseError)

export const getListWorkspacesApiV1WorkspacesGetUrl = (params?: ListWorkspacesApiV1WorkspacesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/workspaces?${stringifiedParams}` : `/api/v1/workspaces`
}

export const listWorkspacesApiV1WorkspacesGet = async (params?: ListWorkspacesApiV1WorkspacesGetParams, options?: RequestInit): Promise<listWorkspacesApiV1WorkspacesGetResponse> => {
  
  const res = await fetch(getListWorkspacesApiV1WorkspacesGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listWorkspacesApiV1WorkspacesGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listWorkspacesApiV1WorkspacesGetResponse
}



/**
 * @summary Create Workspace
 */
export type createWorkspaceApiV1WorkspacesPostResponse201 = {
  data: WorkspaceRes
  status: 201
}

export type createWorkspaceApiV1WorkspacesPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 201>
}
    
export type createWorkspaceApiV1WorkspacesPostResponseSuccess = (createWorkspaceApiV1WorkspacesPostResponse201) & {
  headers: Headers;
};
export type createWorkspaceApiV1WorkspacesPostResponseError = (createWorkspaceApiV1WorkspacesPostResponseDefault) & {
  headers: Headers;
};

export type createWorkspaceApiV1WorkspacesPostResponse = (createWorkspaceApiV1WorkspacesPostResponseSuccess | createWorkspaceApiV1WorkspacesPostResponseError)

export const getCreateWorkspaceApiV1WorkspacesPostUrl = () => {


  

  return `/api/v1/workspaces`
}

export const createWorkspaceApiV1WorkspacesPost = async (createWorkspaceReq: CreateWorkspaceReq, options?: RequestInit): Promise<createWorkspaceApiV1WorkspacesPostResponse> => {
  
  const res = await fetch(getCreateWorkspaceApiV1WorkspacesPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createWorkspaceReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createWorkspaceApiV1WorkspacesPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createWorkspaceApiV1WorkspacesPostResponse
}



/**
 * @summary Get Workspace
 */
export type getWorkspaceApiV1WorkspacesWorkspaceIdGetResponse200 = {
  data: WorkspaceRes
  status: 200
}

export type getWorkspaceApiV1WorkspacesWorkspaceIdGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type getWorkspaceApiV1WorkspacesWorkspaceIdGetResponseSuccess = (getWorkspaceApiV1WorkspacesWorkspaceIdGetResponse200) & {
  headers: Headers;
};
export type getWorkspaceApiV1WorkspacesWorkspaceIdGetResponseError = (getWorkspaceApiV1WorkspacesWorkspaceIdGetResponseDefault) & {
  headers: Headers;
};

export type getWorkspaceApiV1WorkspacesWorkspaceIdGetResponse = (getWorkspaceApiV1WorkspacesWorkspaceIdGetResponseSuccess | getWorkspaceApiV1WorkspacesWorkspaceIdGetResponseError)

export const getGetWorkspaceApiV1WorkspacesWorkspaceIdGetUrl = (workspaceId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}`
}

export const getWorkspaceApiV1WorkspacesWorkspaceIdGet = async (workspaceId: string, options?: RequestInit): Promise<getWorkspaceApiV1WorkspacesWorkspaceIdGetResponse> => {
  
  const res = await fetch(getGetWorkspaceApiV1WorkspacesWorkspaceIdGetUrl(workspaceId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getWorkspaceApiV1WorkspacesWorkspaceIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getWorkspaceApiV1WorkspacesWorkspaceIdGetResponse
}



/**
 * @summary Update Workspace
 */
export type updateWorkspaceApiV1WorkspacesWorkspaceIdPatchResponse200 = {
  data: WorkspaceRes
  status: 200
}

export type updateWorkspaceApiV1WorkspacesWorkspaceIdPatchResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type updateWorkspaceApiV1WorkspacesWorkspaceIdPatchResponseSuccess = (updateWorkspaceApiV1WorkspacesWorkspaceIdPatchResponse200) & {
  headers: Headers;
};
export type updateWorkspaceApiV1WorkspacesWorkspaceIdPatchResponseError = (updateWorkspaceApiV1WorkspacesWorkspaceIdPatchResponseDefault) & {
  headers: Headers;
};

export type updateWorkspaceApiV1WorkspacesWorkspaceIdPatchResponse = (updateWorkspaceApiV1WorkspacesWorkspaceIdPatchResponseSuccess | updateWorkspaceApiV1WorkspacesWorkspaceIdPatchResponseError)

export const getUpdateWorkspaceApiV1WorkspacesWorkspaceIdPatchUrl = (workspaceId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}`
}

export const updateWorkspaceApiV1WorkspacesWorkspaceIdPatch = async (workspaceId: string,
    updateWorkspaceReq: UpdateWorkspaceReq, options?: RequestInit): Promise<updateWorkspaceApiV1WorkspacesWorkspaceIdPatchResponse> => {
  
  const res = await fetch(getUpdateWorkspaceApiV1WorkspacesWorkspaceIdPatchUrl(workspaceId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateWorkspaceReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateWorkspaceApiV1WorkspacesWorkspaceIdPatchResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateWorkspaceApiV1WorkspacesWorkspaceIdPatchResponse
}



/**
 * @summary Archive Workspace
 */
export type archiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteResponse200 = {
  data: ArchiveWorkspaceRes
  status: 200
}

export type archiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type archiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteResponseSuccess = (archiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteResponse200) & {
  headers: Headers;
};
export type archiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteResponseError = (archiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteResponseDefault) & {
  headers: Headers;
};

export type archiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteResponse = (archiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteResponseSuccess | archiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteResponseError)

export const getArchiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteUrl = (workspaceId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}`
}

export const archiveWorkspaceApiV1WorkspacesWorkspaceIdDelete = async (workspaceId: string, options?: RequestInit): Promise<archiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteResponse> => {
  
  const res = await fetch(getArchiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteUrl(workspaceId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: archiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as archiveWorkspaceApiV1WorkspacesWorkspaceIdDeleteResponse
}



/**
 * @summary Publish Workspace
 */
export type publishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostResponse200 = {
  data: WorkspaceRes
  status: 200
}

export type publishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type publishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostResponseSuccess = (publishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostResponse200) & {
  headers: Headers;
};
export type publishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostResponseError = (publishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostResponseDefault) & {
  headers: Headers;
};

export type publishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostResponse = (publishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostResponseSuccess | publishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostResponseError)

export const getPublishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostUrl = (workspaceId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}/publish`
}

export const publishWorkspaceApiV1WorkspacesWorkspaceIdPublishPost = async (workspaceId: string, options?: RequestInit): Promise<publishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostResponse> => {
  
  const res = await fetch(getPublishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: publishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as publishWorkspaceApiV1WorkspacesWorkspaceIdPublishPostResponse
}



/**
 * @summary Share Workspace
 */
export type shareWorkspaceApiV1WorkspacesWorkspaceIdSharePostResponse200 = {
  data: WorkspaceRes
  status: 200
}

export type shareWorkspaceApiV1WorkspacesWorkspaceIdSharePostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type shareWorkspaceApiV1WorkspacesWorkspaceIdSharePostResponseSuccess = (shareWorkspaceApiV1WorkspacesWorkspaceIdSharePostResponse200) & {
  headers: Headers;
};
export type shareWorkspaceApiV1WorkspacesWorkspaceIdSharePostResponseError = (shareWorkspaceApiV1WorkspacesWorkspaceIdSharePostResponseDefault) & {
  headers: Headers;
};

export type shareWorkspaceApiV1WorkspacesWorkspaceIdSharePostResponse = (shareWorkspaceApiV1WorkspacesWorkspaceIdSharePostResponseSuccess | shareWorkspaceApiV1WorkspacesWorkspaceIdSharePostResponseError)

export const getShareWorkspaceApiV1WorkspacesWorkspaceIdSharePostUrl = (workspaceId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}/share`
}

export const shareWorkspaceApiV1WorkspacesWorkspaceIdSharePost = async (workspaceId: string,
    shareWorkspaceReq: ShareWorkspaceReq, options?: RequestInit): Promise<shareWorkspaceApiV1WorkspacesWorkspaceIdSharePostResponse> => {
  
  const res = await fetch(getShareWorkspaceApiV1WorkspacesWorkspaceIdSharePostUrl(workspaceId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      shareWorkspaceReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: shareWorkspaceApiV1WorkspacesWorkspaceIdSharePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as shareWorkspaceApiV1WorkspacesWorkspaceIdSharePostResponse
}



/**
 * @summary Archive Workspace Action
 */
export type archiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostResponse200 = {
  data: ArchiveWorkspaceRes
  status: 200
}

export type archiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type archiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostResponseSuccess = (archiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostResponse200) & {
  headers: Headers;
};
export type archiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostResponseError = (archiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostResponseDefault) & {
  headers: Headers;
};

export type archiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostResponse = (archiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostResponseSuccess | archiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostResponseError)

export const getArchiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostUrl = (workspaceId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}/archive`
}

export const archiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePost = async (workspaceId: string, options?: RequestInit): Promise<archiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostResponse> => {
  
  const res = await fetch(getArchiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostUrl(workspaceId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: archiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as archiveWorkspaceActionApiV1WorkspacesWorkspaceIdArchivePostResponse
}



/**
 * @deprecated
 * @summary List Documents
 */
export type listDocumentsApiV1DocumentsGetResponse200 = {
  data: DocumentsListRes
  status: 200
}

export type listDocumentsApiV1DocumentsGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type listDocumentsApiV1DocumentsGetResponseSuccess = (listDocumentsApiV1DocumentsGetResponse200) & {
  headers: Headers;
};
export type listDocumentsApiV1DocumentsGetResponseError = (listDocumentsApiV1DocumentsGetResponseDefault) & {
  headers: Headers;
};

export type listDocumentsApiV1DocumentsGetResponse = (listDocumentsApiV1DocumentsGetResponseSuccess | listDocumentsApiV1DocumentsGetResponseError)

export const getListDocumentsApiV1DocumentsGetUrl = (params?: ListDocumentsApiV1DocumentsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/documents?${stringifiedParams}` : `/api/v1/documents`
}

export const listDocumentsApiV1DocumentsGet = async (params?: ListDocumentsApiV1DocumentsGetParams, options?: RequestInit): Promise<listDocumentsApiV1DocumentsGetResponse> => {
  
  const res = await fetch(getListDocumentsApiV1DocumentsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listDocumentsApiV1DocumentsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listDocumentsApiV1DocumentsGetResponse
}



/**
 * @deprecated
 * @summary Get Document
 */
export type getDocumentApiV1DocumentsDocumentIdGetResponse200 = {
  data: DocumentDetailRes
  status: 200
}

export type getDocumentApiV1DocumentsDocumentIdGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type getDocumentApiV1DocumentsDocumentIdGetResponseSuccess = (getDocumentApiV1DocumentsDocumentIdGetResponse200) & {
  headers: Headers;
};
export type getDocumentApiV1DocumentsDocumentIdGetResponseError = (getDocumentApiV1DocumentsDocumentIdGetResponseDefault) & {
  headers: Headers;
};

export type getDocumentApiV1DocumentsDocumentIdGetResponse = (getDocumentApiV1DocumentsDocumentIdGetResponseSuccess | getDocumentApiV1DocumentsDocumentIdGetResponseError)

export const getGetDocumentApiV1DocumentsDocumentIdGetUrl = (documentId: string,
    params?: GetDocumentApiV1DocumentsDocumentIdGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/documents/${documentId}?${stringifiedParams}` : `/api/v1/documents/${documentId}`
}

export const getDocumentApiV1DocumentsDocumentIdGet = async (documentId: string,
    params?: GetDocumentApiV1DocumentsDocumentIdGetParams, options?: RequestInit): Promise<getDocumentApiV1DocumentsDocumentIdGetResponse> => {
  
  const res = await fetch(getGetDocumentApiV1DocumentsDocumentIdGetUrl(documentId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getDocumentApiV1DocumentsDocumentIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getDocumentApiV1DocumentsDocumentIdGetResponse
}



/**
 * @deprecated
 * @summary Delete Document
 */
export type deleteDocumentApiV1DocumentsDocumentIdDeleteResponse200 = {
  data: DeleteDocumentRes
  status: 200
}

export type deleteDocumentApiV1DocumentsDocumentIdDeleteResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type deleteDocumentApiV1DocumentsDocumentIdDeleteResponseSuccess = (deleteDocumentApiV1DocumentsDocumentIdDeleteResponse200) & {
  headers: Headers;
};
export type deleteDocumentApiV1DocumentsDocumentIdDeleteResponseError = (deleteDocumentApiV1DocumentsDocumentIdDeleteResponseDefault) & {
  headers: Headers;
};

export type deleteDocumentApiV1DocumentsDocumentIdDeleteResponse = (deleteDocumentApiV1DocumentsDocumentIdDeleteResponseSuccess | deleteDocumentApiV1DocumentsDocumentIdDeleteResponseError)

export const getDeleteDocumentApiV1DocumentsDocumentIdDeleteUrl = (documentId: string,
    params?: DeleteDocumentApiV1DocumentsDocumentIdDeleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/documents/${documentId}?${stringifiedParams}` : `/api/v1/documents/${documentId}`
}

export const deleteDocumentApiV1DocumentsDocumentIdDelete = async (documentId: string,
    params?: DeleteDocumentApiV1DocumentsDocumentIdDeleteParams, options?: RequestInit): Promise<deleteDocumentApiV1DocumentsDocumentIdDeleteResponse> => {
  
  const res = await fetch(getDeleteDocumentApiV1DocumentsDocumentIdDeleteUrl(documentId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteDocumentApiV1DocumentsDocumentIdDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteDocumentApiV1DocumentsDocumentIdDeleteResponse
}



/**
 * @deprecated
 * @summary Upload Document
 */
export type uploadDocumentApiV1DocumentsUploadPostResponse200 = {
  data: UploadDocumentRes
  status: 200
}

export type uploadDocumentApiV1DocumentsUploadPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type uploadDocumentApiV1DocumentsUploadPostResponseSuccess = (uploadDocumentApiV1DocumentsUploadPostResponse200) & {
  headers: Headers;
};
export type uploadDocumentApiV1DocumentsUploadPostResponseError = (uploadDocumentApiV1DocumentsUploadPostResponseDefault) & {
  headers: Headers;
};

export type uploadDocumentApiV1DocumentsUploadPostResponse = (uploadDocumentApiV1DocumentsUploadPostResponseSuccess | uploadDocumentApiV1DocumentsUploadPostResponseError)

export const getUploadDocumentApiV1DocumentsUploadPostUrl = (params?: UploadDocumentApiV1DocumentsUploadPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/documents/upload?${stringifiedParams}` : `/api/v1/documents/upload`
}

export const uploadDocumentApiV1DocumentsUploadPost = async (bodyUploadDocumentApiV1DocumentsUploadPost: BodyUploadDocumentApiV1DocumentsUploadPost,
    params?: UploadDocumentApiV1DocumentsUploadPostParams, options?: RequestInit): Promise<uploadDocumentApiV1DocumentsUploadPostResponse> => {
    const formData = new FormData();
formData.append(`file`, bodyUploadDocumentApiV1DocumentsUploadPost.file)
if(bodyUploadDocumentApiV1DocumentsUploadPost.title !== undefined && bodyUploadDocumentApiV1DocumentsUploadPost.title !== null) {
 formData.append(`title`, bodyUploadDocumentApiV1DocumentsUploadPost.title)
 }
if(bodyUploadDocumentApiV1DocumentsUploadPost.source !== undefined && bodyUploadDocumentApiV1DocumentsUploadPost.source !== null) {
 formData.append(`source`, bodyUploadDocumentApiV1DocumentsUploadPost.source)
 }
if(bodyUploadDocumentApiV1DocumentsUploadPost.metadata !== undefined && bodyUploadDocumentApiV1DocumentsUploadPost.metadata !== null) {
 formData.append(`metadata`, bodyUploadDocumentApiV1DocumentsUploadPost.metadata)
 }

  const res = await fetch(getUploadDocumentApiV1DocumentsUploadPostUrl(params),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: uploadDocumentApiV1DocumentsUploadPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as uploadDocumentApiV1DocumentsUploadPostResponse
}



/**
 * @deprecated
 * @summary Reprocess Document
 */
export type reprocessDocumentApiV1DocumentsDocumentIdReprocessPostResponse202 = {
  data: ReprocessDocumentRes
  status: 202
}

export type reprocessDocumentApiV1DocumentsDocumentIdReprocessPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 202>
}
    
export type reprocessDocumentApiV1DocumentsDocumentIdReprocessPostResponseSuccess = (reprocessDocumentApiV1DocumentsDocumentIdReprocessPostResponse202) & {
  headers: Headers;
};
export type reprocessDocumentApiV1DocumentsDocumentIdReprocessPostResponseError = (reprocessDocumentApiV1DocumentsDocumentIdReprocessPostResponseDefault) & {
  headers: Headers;
};

export type reprocessDocumentApiV1DocumentsDocumentIdReprocessPostResponse = (reprocessDocumentApiV1DocumentsDocumentIdReprocessPostResponseSuccess | reprocessDocumentApiV1DocumentsDocumentIdReprocessPostResponseError)

export const getReprocessDocumentApiV1DocumentsDocumentIdReprocessPostUrl = (documentId: string,
    params?: ReprocessDocumentApiV1DocumentsDocumentIdReprocessPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/documents/${documentId}/reprocess?${stringifiedParams}` : `/api/v1/documents/${documentId}/reprocess`
}

export const reprocessDocumentApiV1DocumentsDocumentIdReprocessPost = async (documentId: string,
    params?: ReprocessDocumentApiV1DocumentsDocumentIdReprocessPostParams, options?: RequestInit): Promise<reprocessDocumentApiV1DocumentsDocumentIdReprocessPostResponse> => {
  
  const res = await fetch(getReprocessDocumentApiV1DocumentsDocumentIdReprocessPostUrl(documentId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: reprocessDocumentApiV1DocumentsDocumentIdReprocessPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as reprocessDocumentApiV1DocumentsDocumentIdReprocessPostResponse
}



/**
 * @deprecated
 * @summary Ingest Text
 */
export type ingestTextApiV1IngestTextPostResponse200 = {
  data: IngestTextRes
  status: 200
}

export type ingestTextApiV1IngestTextPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type ingestTextApiV1IngestTextPostResponseSuccess = (ingestTextApiV1IngestTextPostResponse200) & {
  headers: Headers;
};
export type ingestTextApiV1IngestTextPostResponseError = (ingestTextApiV1IngestTextPostResponseDefault) & {
  headers: Headers;
};

export type ingestTextApiV1IngestTextPostResponse = (ingestTextApiV1IngestTextPostResponseSuccess | ingestTextApiV1IngestTextPostResponseError)

export const getIngestTextApiV1IngestTextPostUrl = (params?: IngestTextApiV1IngestTextPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/ingest/text?${stringifiedParams}` : `/api/v1/ingest/text`
}

export const ingestTextApiV1IngestTextPost = async (ingestTextReq: IngestTextReq,
    params?: IngestTextApiV1IngestTextPostParams, options?: RequestInit): Promise<ingestTextApiV1IngestTextPostResponse> => {
  
  const res = await fetch(getIngestTextApiV1IngestTextPostUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestTextReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ingestTextApiV1IngestTextPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ingestTextApiV1IngestTextPostResponse
}



/**
 * Ingest multiple documents in a single request.

Processes up to 10 documents sequentially.
Returns results for all successfully ingested documents.
 * @deprecated
 * @summary Ingest Batch
 */
export type ingestBatchApiV1IngestBatchPostResponse200 = {
  data: IngestBatchRes
  status: 200
}

export type ingestBatchApiV1IngestBatchPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type ingestBatchApiV1IngestBatchPostResponseSuccess = (ingestBatchApiV1IngestBatchPostResponse200) & {
  headers: Headers;
};
export type ingestBatchApiV1IngestBatchPostResponseError = (ingestBatchApiV1IngestBatchPostResponseDefault) & {
  headers: Headers;
};

export type ingestBatchApiV1IngestBatchPostResponse = (ingestBatchApiV1IngestBatchPostResponseSuccess | ingestBatchApiV1IngestBatchPostResponseError)

export const getIngestBatchApiV1IngestBatchPostUrl = (params?: IngestBatchApiV1IngestBatchPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/ingest/batch?${stringifiedParams}` : `/api/v1/ingest/batch`
}

export const ingestBatchApiV1IngestBatchPost = async (ingestBatchReq: IngestBatchReq,
    params?: IngestBatchApiV1IngestBatchPostParams, options?: RequestInit): Promise<ingestBatchApiV1IngestBatchPostResponse> => {
  
  const res = await fetch(getIngestBatchApiV1IngestBatchPostUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestBatchReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ingestBatchApiV1IngestBatchPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ingestBatchApiV1IngestBatchPostResponse
}



/**
 * @deprecated
 * @summary Query
 */
export type queryApiV1QueryPostResponse200 = {
  data: QueryRes
  status: 200
}

export type queryApiV1QueryPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type queryApiV1QueryPostResponseSuccess = (queryApiV1QueryPostResponse200) & {
  headers: Headers;
};
export type queryApiV1QueryPostResponseError = (queryApiV1QueryPostResponseDefault) & {
  headers: Headers;
};

export type queryApiV1QueryPostResponse = (queryApiV1QueryPostResponseSuccess | queryApiV1QueryPostResponseError)

export const getQueryApiV1QueryPostUrl = (params?: QueryApiV1QueryPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/query?${stringifiedParams}` : `/api/v1/query`
}

export const queryApiV1QueryPost = async (queryReq: QueryReq,
    params?: QueryApiV1QueryPostParams, options?: RequestInit): Promise<queryApiV1QueryPostResponse> => {
  
  const res = await fetch(getQueryApiV1QueryPostUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: queryApiV1QueryPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as queryApiV1QueryPostResponse
}



/**
 * R: RAG endpoint using Clean Architecture (Use Case pattern).

This endpoint demonstrates the architecture improvement:
- Business logic in use case (testable, framework-independent)
- Dependency injection via FastAPI Depends
- Separation of concerns (HTTP ‚Üî Business Logic)

Uses the same query contract as /query with a generation step.
Set use_mmr=true for diverse results (reduces redundant chunks).
 * @deprecated
 * @summary Ask
 */
export type askApiV1AskPostResponse200 = {
  data: AskRes
  status: 200
}

export type askApiV1AskPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type askApiV1AskPostResponseSuccess = (askApiV1AskPostResponse200) & {
  headers: Headers;
};
export type askApiV1AskPostResponseError = (askApiV1AskPostResponseDefault) & {
  headers: Headers;
};

export type askApiV1AskPostResponse = (askApiV1AskPostResponseSuccess | askApiV1AskPostResponseError)

export const getAskApiV1AskPostUrl = (params?: AskApiV1AskPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/ask?${stringifiedParams}` : `/api/v1/ask`
}

export const askApiV1AskPost = async (queryReq: QueryReq,
    params?: AskApiV1AskPostParams, options?: RequestInit): Promise<askApiV1AskPostResponse> => {
  
  const res = await fetch(getAskApiV1AskPostUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: askApiV1AskPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as askApiV1AskPostResponse
}



/**
 * R: Streaming RAG endpoint using Server-Sent Events.

Returns tokens as they are generated by the LLM for better UX.
Uses the same query contract as /ask but streams the response.

SSE Events:
- sources: Initial event with retrieved chunks
- token: Individual tokens as generated
- done: Final event with complete answer
- error: Error event if generation fails
 * @deprecated
 * @summary Ask Stream
 */
export type askStreamApiV1AskStreamPostResponse200 = {
  data: unknown
  status: 200
}

export type askStreamApiV1AskStreamPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type askStreamApiV1AskStreamPostResponseSuccess = (askStreamApiV1AskStreamPostResponse200) & {
  headers: Headers;
};
export type askStreamApiV1AskStreamPostResponseError = (askStreamApiV1AskStreamPostResponseDefault) & {
  headers: Headers;
};

export type askStreamApiV1AskStreamPostResponse = (askStreamApiV1AskStreamPostResponseSuccess | askStreamApiV1AskStreamPostResponseError)

export const getAskStreamApiV1AskStreamPostUrl = (params?: AskStreamApiV1AskStreamPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/ask/stream?${stringifiedParams}` : `/api/v1/ask/stream`
}

export const askStreamApiV1AskStreamPost = async (queryReq: QueryReq,
    params?: AskStreamApiV1AskStreamPostParams, options?: RequestInit): Promise<askStreamApiV1AskStreamPostResponse> => {
  
  const res = await fetch(getAskStreamApiV1AskStreamPostUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: askStreamApiV1AskStreamPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as askStreamApiV1AskStreamPostResponse
}



/**
 * @summary List Workspace Documents
 */
export type listWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetResponse200 = {
  data: DocumentsListRes
  status: 200
}

export type listWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type listWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetResponseSuccess = (listWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetResponse200) & {
  headers: Headers;
};
export type listWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetResponseError = (listWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetResponseDefault) & {
  headers: Headers;
};

export type listWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetResponse = (listWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetResponseSuccess | listWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetResponseError)

export const getListWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetUrl = (workspaceId: string,
    params?: ListWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/workspaces/${workspaceId}/documents?${stringifiedParams}` : `/api/v1/workspaces/${workspaceId}/documents`
}

export const listWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGet = async (workspaceId: string,
    params?: ListWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetParams, options?: RequestInit): Promise<listWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetResponse> => {
  
  const res = await fetch(getListWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetUrl(workspaceId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listWorkspaceDocumentsApiV1WorkspacesWorkspaceIdDocumentsGetResponse
}



/**
 * @summary Get Workspace Document
 */
export type getWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponse200 = {
  data: DocumentDetailRes
  status: 200
}

export type getWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type getWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponseSuccess = (getWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponse200) & {
  headers: Headers;
};
export type getWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponseError = (getWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponseDefault) & {
  headers: Headers;
};

export type getWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponse = (getWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponseSuccess | getWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponseError)

export const getGetWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetUrl = (workspaceId: string,
    documentId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}/documents/${documentId}`
}

export const getWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGet = async (workspaceId: string,
    documentId: string, options?: RequestInit): Promise<getWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponse> => {
  
  const res = await fetch(getGetWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetUrl(workspaceId,documentId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdGetResponse
}



/**
 * @summary Delete Workspace Document
 */
export type deleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponse200 = {
  data: DeleteDocumentRes
  status: 200
}

export type deleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type deleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponseSuccess = (deleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponse200) & {
  headers: Headers;
};
export type deleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponseError = (deleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponseDefault) & {
  headers: Headers;
};

export type deleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponse = (deleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponseSuccess | deleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponseError)

export const getDeleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteUrl = (workspaceId: string,
    documentId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}/documents/${documentId}`
}

export const deleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDelete = async (workspaceId: string,
    documentId: string, options?: RequestInit): Promise<deleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponse> => {
  
  const res = await fetch(getDeleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteUrl(workspaceId,documentId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdDeleteResponse
}



/**
 * @summary Upload Workspace Document
 */
export type uploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostResponse200 = {
  data: UploadDocumentRes
  status: 200
}

export type uploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type uploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostResponseSuccess = (uploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostResponse200) & {
  headers: Headers;
};
export type uploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostResponseError = (uploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostResponseDefault) & {
  headers: Headers;
};

export type uploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostResponse = (uploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostResponseSuccess | uploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostResponseError)

export const getUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostUrl = (workspaceId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}/documents/upload`
}

export const uploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost = async (workspaceId: string,
    bodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost: BodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost, options?: RequestInit): Promise<uploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostResponse> => {
    const formData = new FormData();
formData.append(`file`, bodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost.file)
if(bodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost.title !== undefined && bodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost.title !== null) {
 formData.append(`title`, bodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost.title)
 }
if(bodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost.source !== undefined && bodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost.source !== null) {
 formData.append(`source`, bodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost.source)
 }
if(bodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost.metadata !== undefined && bodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost.metadata !== null) {
 formData.append(`metadata`, bodyUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPost.metadata)
 }

  const res = await fetch(getUploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: uploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as uploadWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsUploadPostResponse
}



/**
 * @summary Reprocess Workspace Document
 */
export type reprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponse202 = {
  data: ReprocessDocumentRes
  status: 202
}

export type reprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 202>
}
    
export type reprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponseSuccess = (reprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponse202) & {
  headers: Headers;
};
export type reprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponseError = (reprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponseDefault) & {
  headers: Headers;
};

export type reprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponse = (reprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponseSuccess | reprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponseError)

export const getReprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostUrl = (workspaceId: string,
    documentId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}/documents/${documentId}/reprocess`
}

export const reprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPost = async (workspaceId: string,
    documentId: string, options?: RequestInit): Promise<reprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponse> => {
  
  const res = await fetch(getReprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostUrl(workspaceId,documentId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: reprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as reprocessWorkspaceDocumentApiV1WorkspacesWorkspaceIdDocumentsDocumentIdReprocessPostResponse
}



/**
 * @summary Ingest Workspace Text
 */
export type ingestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostResponse200 = {
  data: IngestTextRes
  status: 200
}

export type ingestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type ingestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostResponseSuccess = (ingestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostResponse200) & {
  headers: Headers;
};
export type ingestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostResponseError = (ingestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostResponseDefault) & {
  headers: Headers;
};

export type ingestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostResponse = (ingestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostResponseSuccess | ingestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostResponseError)

export const getIngestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostUrl = (workspaceId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}/ingest/text`
}

export const ingestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPost = async (workspaceId: string,
    ingestTextReq: IngestTextReq, options?: RequestInit): Promise<ingestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostResponse> => {
  
  const res = await fetch(getIngestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestTextReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ingestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ingestWorkspaceTextApiV1WorkspacesWorkspaceIdIngestTextPostResponse
}



/**
 * @summary Ingest Workspace Batch
 */
export type ingestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostResponse200 = {
  data: IngestBatchRes
  status: 200
}

export type ingestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type ingestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostResponseSuccess = (ingestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostResponse200) & {
  headers: Headers;
};
export type ingestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostResponseError = (ingestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostResponseDefault) & {
  headers: Headers;
};

export type ingestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostResponse = (ingestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostResponseSuccess | ingestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostResponseError)

export const getIngestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostUrl = (workspaceId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}/ingest/batch`
}

export const ingestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPost = async (workspaceId: string,
    ingestBatchReq: IngestBatchReq, options?: RequestInit): Promise<ingestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostResponse> => {
  
  const res = await fetch(getIngestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestBatchReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ingestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ingestWorkspaceBatchApiV1WorkspacesWorkspaceIdIngestBatchPostResponse
}



/**
 * @summary Query Workspace
 */
export type queryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostResponse200 = {
  data: QueryRes
  status: 200
}

export type queryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type queryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostResponseSuccess = (queryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostResponse200) & {
  headers: Headers;
};
export type queryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostResponseError = (queryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostResponseDefault) & {
  headers: Headers;
};

export type queryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostResponse = (queryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostResponseSuccess | queryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostResponseError)

export const getQueryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostUrl = (workspaceId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}/query`
}

export const queryWorkspaceApiV1WorkspacesWorkspaceIdQueryPost = async (workspaceId: string,
    queryReq: QueryReq, options?: RequestInit): Promise<queryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostResponse> => {
  
  const res = await fetch(getQueryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: queryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as queryWorkspaceApiV1WorkspacesWorkspaceIdQueryPostResponse
}



/**
 * @summary Ask Workspace
 */
export type askWorkspaceApiV1WorkspacesWorkspaceIdAskPostResponse200 = {
  data: AskRes
  status: 200
}

export type askWorkspaceApiV1WorkspacesWorkspaceIdAskPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type askWorkspaceApiV1WorkspacesWorkspaceIdAskPostResponseSuccess = (askWorkspaceApiV1WorkspacesWorkspaceIdAskPostResponse200) & {
  headers: Headers;
};
export type askWorkspaceApiV1WorkspacesWorkspaceIdAskPostResponseError = (askWorkspaceApiV1WorkspacesWorkspaceIdAskPostResponseDefault) & {
  headers: Headers;
};

export type askWorkspaceApiV1WorkspacesWorkspaceIdAskPostResponse = (askWorkspaceApiV1WorkspacesWorkspaceIdAskPostResponseSuccess | askWorkspaceApiV1WorkspacesWorkspaceIdAskPostResponseError)

export const getAskWorkspaceApiV1WorkspacesWorkspaceIdAskPostUrl = (workspaceId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}/ask`
}

export const askWorkspaceApiV1WorkspacesWorkspaceIdAskPost = async (workspaceId: string,
    queryReq: QueryReq, options?: RequestInit): Promise<askWorkspaceApiV1WorkspacesWorkspaceIdAskPostResponse> => {
  
  const res = await fetch(getAskWorkspaceApiV1WorkspacesWorkspaceIdAskPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: askWorkspaceApiV1WorkspacesWorkspaceIdAskPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as askWorkspaceApiV1WorkspacesWorkspaceIdAskPostResponse
}



/**
 * @summary Ask Workspace Stream
 */
export type askWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostResponse200 = {
  data: unknown
  status: 200
}

export type askWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostResponseDefault = {
  data: ErrorDetail
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type askWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostResponseSuccess = (askWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostResponse200) & {
  headers: Headers;
};
export type askWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostResponseError = (askWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostResponseDefault) & {
  headers: Headers;
};

export type askWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostResponse = (askWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostResponseSuccess | askWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostResponseError)

export const getAskWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostUrl = (workspaceId: string,) => {


  

  return `/api/v1/workspaces/${workspaceId}/ask/stream`
}

export const askWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPost = async (workspaceId: string,
    queryReq: QueryReq, options?: RequestInit): Promise<askWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostResponse> => {
  
  const res = await fetch(getAskWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostUrl(workspaceId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: askWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as askWorkspaceStreamApiV1WorkspacesWorkspaceIdAskStreamPostResponse
}



/**
 * R: Enhanced health check that verifies system dependencies.

Args:
    full: If True, also check Google API connectivity (slower)
          Respects HEALTHCHECK_GOOGLE_ENABLED setting

Returns:
    ok: True if all checked systems operational
    db: "connected" or "disconnected"
    google: "available", "unavailable", "disabled", or "skipped" (only with full=true)
    request_id: Correlation ID for this request
 * @summary Healthz
 */
export type healthzHealthzGetResponse200 = {
  data: unknown
  status: 200
}

export type healthzHealthzGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type healthzHealthzGetResponseSuccess = (healthzHealthzGetResponse200) & {
  headers: Headers;
};
export type healthzHealthzGetResponseError = (healthzHealthzGetResponse422) & {
  headers: Headers;
};

export type healthzHealthzGetResponse = (healthzHealthzGetResponseSuccess | healthzHealthzGetResponseError)

export const getHealthzHealthzGetUrl = (params?: HealthzHealthzGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/healthz?${stringifiedParams}` : `/healthz`
}

export const healthzHealthzGet = async (params?: HealthzHealthzGetParams, options?: RequestInit): Promise<healthzHealthzGetResponse> => {
  
  const res = await fetch(getHealthzHealthzGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: healthzHealthzGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as healthzHealthzGetResponse
}



/**
 * R: Minimal readiness check for core dependencies only.

Returns:
    ok: True if core dependencies are operational
    db: "connected" or "disconnected"
    request_id: Correlation ID for this request
 * @summary Readyz
 */
export type readyzReadyzGetResponse200 = {
  data: unknown
  status: 200
}
    
export type readyzReadyzGetResponseSuccess = (readyzReadyzGetResponse200) & {
  headers: Headers;
};
;

export type readyzReadyzGetResponse = (readyzReadyzGetResponseSuccess)

export const getReadyzReadyzGetUrl = () => {


  

  return `/readyz`
}

export const readyzReadyzGet = async ( options?: RequestInit): Promise<readyzReadyzGetResponse> => {
  
  const res = await fetch(getReadyzReadyzGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: readyzReadyzGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as readyzReadyzGetResponse
}



/**
 * R: Expose Prometheus metrics.

Returns:
    Prometheus text format metrics
 * @summary Metrics
 */
export type metricsMetricsGetResponse200 = {
  data: unknown
  status: 200
}

export type metricsMetricsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type metricsMetricsGetResponseSuccess = (metricsMetricsGetResponse200) & {
  headers: Headers;
};
export type metricsMetricsGetResponseError = (metricsMetricsGetResponse422) & {
  headers: Headers;
};

export type metricsMetricsGetResponse = (metricsMetricsGetResponseSuccess | metricsMetricsGetResponseError)

export const getMetricsMetricsGetUrl = () => {


  

  return `/metrics`
}

export const metricsMetricsGet = async ( options?: RequestInit): Promise<metricsMetricsGetResponse> => {
  
  const res = await fetch(getMetricsMetricsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: metricsMetricsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as metricsMetricsGetResponse
}
