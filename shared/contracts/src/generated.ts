/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * RAG Corp API
 * OpenAPI spec version: 0.1.0
 */
export interface AskRes {
  answer: string;
  sources: string[];
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface IngestBatchReq {
  /**
   * List of documents to ingest (1-10)
   * @minItems 1
   * @maxItems 10
   */
  documents: IngestTextReq[];
}

export interface IngestBatchRes {
  documents: IngestTextRes[];
  total_chunks: number;
}

/**
 * Optional source URL or identifier (max 500 chars)
 */
export type IngestTextReqSource = string | null;

/**
 * Additional custom metadata (JSONB)
 */
export type IngestTextReqMetadata = { [key: string]: unknown };

export interface IngestTextReq {
  /**
   * Document title (1-200 chars)
   * @minLength 1
   * @maxLength 200
   */
  title: string;
  /**
   * Full document text to be chunked (1-100,000 chars)
   * @minLength 1
   * @maxLength 100000
   */
  text: string;
  /** Optional source URL or identifier (max 500 chars) */
  source?: IngestTextReqSource;
  /** Additional custom metadata (JSONB) */
  metadata?: IngestTextReqMetadata;
}

export interface IngestTextRes {
  document_id: string;
  chunks: number;
}

export interface Match {
  chunk_id: string;
  document_id: string;
  content: string;
  score: number;
}

export interface QueryReq {
  /**
   * User's natural language question (1-2,000 chars)
   * @minLength 1
   * @maxLength 2000
   */
  query: string;
  /**
   * Number of similar chunks to retrieve (1-20)
   * @minimum 1
   * @maximum 20
   */
  top_k?: number;
}

export interface QueryRes {
  matches: Match[];
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type HealthzHealthzGetParams = {
full?: boolean;
};

/**
 * @summary Ingest Text
 */
export type ingestTextV1IngestTextPostResponse200 = {
  data: IngestTextRes
  status: 200
}

export type ingestTextV1IngestTextPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type ingestTextV1IngestTextPostResponseSuccess = (ingestTextV1IngestTextPostResponse200) & {
  headers: Headers;
};
export type ingestTextV1IngestTextPostResponseError = (ingestTextV1IngestTextPostResponse422) & {
  headers: Headers;
};

export type ingestTextV1IngestTextPostResponse = (ingestTextV1IngestTextPostResponseSuccess | ingestTextV1IngestTextPostResponseError)

export const getIngestTextV1IngestTextPostUrl = () => {


  

  return `/v1/ingest/text`
}

export const ingestTextV1IngestTextPost = async (ingestTextReq: IngestTextReq, options?: RequestInit): Promise<ingestTextV1IngestTextPostResponse> => {
  
  const res = await fetch(getIngestTextV1IngestTextPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestTextReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ingestTextV1IngestTextPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ingestTextV1IngestTextPostResponse
}



/**
 * Ingest multiple documents in a single request.

Processes up to 10 documents sequentially.
Returns results for all successfully ingested documents.
 * @summary Ingest Batch
 */
export type ingestBatchV1IngestBatchPostResponse200 = {
  data: IngestBatchRes
  status: 200
}

export type ingestBatchV1IngestBatchPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type ingestBatchV1IngestBatchPostResponseSuccess = (ingestBatchV1IngestBatchPostResponse200) & {
  headers: Headers;
};
export type ingestBatchV1IngestBatchPostResponseError = (ingestBatchV1IngestBatchPostResponse422) & {
  headers: Headers;
};

export type ingestBatchV1IngestBatchPostResponse = (ingestBatchV1IngestBatchPostResponseSuccess | ingestBatchV1IngestBatchPostResponseError)

export const getIngestBatchV1IngestBatchPostUrl = () => {


  

  return `/v1/ingest/batch`
}

export const ingestBatchV1IngestBatchPost = async (ingestBatchReq: IngestBatchReq, options?: RequestInit): Promise<ingestBatchV1IngestBatchPostResponse> => {
  
  const res = await fetch(getIngestBatchV1IngestBatchPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestBatchReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ingestBatchV1IngestBatchPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ingestBatchV1IngestBatchPostResponse
}



/**
 * @summary Query
 */
export type queryV1QueryPostResponse200 = {
  data: QueryRes
  status: 200
}

export type queryV1QueryPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type queryV1QueryPostResponseSuccess = (queryV1QueryPostResponse200) & {
  headers: Headers;
};
export type queryV1QueryPostResponseError = (queryV1QueryPostResponse422) & {
  headers: Headers;
};

export type queryV1QueryPostResponse = (queryV1QueryPostResponseSuccess | queryV1QueryPostResponseError)

export const getQueryV1QueryPostUrl = () => {


  

  return `/v1/query`
}

export const queryV1QueryPost = async (queryReq: QueryReq, options?: RequestInit): Promise<queryV1QueryPostResponse> => {
  
  const res = await fetch(getQueryV1QueryPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: queryV1QueryPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as queryV1QueryPostResponse
}



/**
 * R: RAG endpoint using Clean Architecture (Use Case pattern).

This endpoint demonstrates the architecture improvement:
- Business logic in use case (testable, framework-independent)
- Dependency injection via FastAPI Depends
- Separation of concerns (HTTP â†” Business Logic)

Uses the same query contract as /query with a generation step.
 * @summary Ask
 */
export type askV1AskPostResponse200 = {
  data: AskRes
  status: 200
}

export type askV1AskPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type askV1AskPostResponseSuccess = (askV1AskPostResponse200) & {
  headers: Headers;
};
export type askV1AskPostResponseError = (askV1AskPostResponse422) & {
  headers: Headers;
};

export type askV1AskPostResponse = (askV1AskPostResponseSuccess | askV1AskPostResponseError)

export const getAskV1AskPostUrl = () => {


  

  return `/v1/ask`
}

export const askV1AskPost = async (queryReq: QueryReq, options?: RequestInit): Promise<askV1AskPostResponse> => {
  
  const res = await fetch(getAskV1AskPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: askV1AskPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as askV1AskPostResponse
}



/**
 * @summary Ingest Text
 */
export type ingestTextApiV1IngestTextPostResponse200 = {
  data: IngestTextRes
  status: 200
}

export type ingestTextApiV1IngestTextPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type ingestTextApiV1IngestTextPostResponseSuccess = (ingestTextApiV1IngestTextPostResponse200) & {
  headers: Headers;
};
export type ingestTextApiV1IngestTextPostResponseError = (ingestTextApiV1IngestTextPostResponse422) & {
  headers: Headers;
};

export type ingestTextApiV1IngestTextPostResponse = (ingestTextApiV1IngestTextPostResponseSuccess | ingestTextApiV1IngestTextPostResponseError)

export const getIngestTextApiV1IngestTextPostUrl = () => {


  

  return `/api/v1/ingest/text`
}

export const ingestTextApiV1IngestTextPost = async (ingestTextReq: IngestTextReq, options?: RequestInit): Promise<ingestTextApiV1IngestTextPostResponse> => {
  
  const res = await fetch(getIngestTextApiV1IngestTextPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestTextReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ingestTextApiV1IngestTextPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ingestTextApiV1IngestTextPostResponse
}



/**
 * Ingest multiple documents in a single request.

Processes up to 10 documents sequentially.
Returns results for all successfully ingested documents.
 * @summary Ingest Batch
 */
export type ingestBatchApiV1IngestBatchPostResponse200 = {
  data: IngestBatchRes
  status: 200
}

export type ingestBatchApiV1IngestBatchPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type ingestBatchApiV1IngestBatchPostResponseSuccess = (ingestBatchApiV1IngestBatchPostResponse200) & {
  headers: Headers;
};
export type ingestBatchApiV1IngestBatchPostResponseError = (ingestBatchApiV1IngestBatchPostResponse422) & {
  headers: Headers;
};

export type ingestBatchApiV1IngestBatchPostResponse = (ingestBatchApiV1IngestBatchPostResponseSuccess | ingestBatchApiV1IngestBatchPostResponseError)

export const getIngestBatchApiV1IngestBatchPostUrl = () => {


  

  return `/api/v1/ingest/batch`
}

export const ingestBatchApiV1IngestBatchPost = async (ingestBatchReq: IngestBatchReq, options?: RequestInit): Promise<ingestBatchApiV1IngestBatchPostResponse> => {
  
  const res = await fetch(getIngestBatchApiV1IngestBatchPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ingestBatchReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: ingestBatchApiV1IngestBatchPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as ingestBatchApiV1IngestBatchPostResponse
}



/**
 * @summary Query
 */
export type queryApiV1QueryPostResponse200 = {
  data: QueryRes
  status: 200
}

export type queryApiV1QueryPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type queryApiV1QueryPostResponseSuccess = (queryApiV1QueryPostResponse200) & {
  headers: Headers;
};
export type queryApiV1QueryPostResponseError = (queryApiV1QueryPostResponse422) & {
  headers: Headers;
};

export type queryApiV1QueryPostResponse = (queryApiV1QueryPostResponseSuccess | queryApiV1QueryPostResponseError)

export const getQueryApiV1QueryPostUrl = () => {


  

  return `/api/v1/query`
}

export const queryApiV1QueryPost = async (queryReq: QueryReq, options?: RequestInit): Promise<queryApiV1QueryPostResponse> => {
  
  const res = await fetch(getQueryApiV1QueryPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: queryApiV1QueryPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as queryApiV1QueryPostResponse
}



/**
 * R: RAG endpoint using Clean Architecture (Use Case pattern).

This endpoint demonstrates the architecture improvement:
- Business logic in use case (testable, framework-independent)
- Dependency injection via FastAPI Depends
- Separation of concerns (HTTP â†” Business Logic)

Uses the same query contract as /query with a generation step.
 * @summary Ask
 */
export type askApiV1AskPostResponse200 = {
  data: AskRes
  status: 200
}

export type askApiV1AskPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type askApiV1AskPostResponseSuccess = (askApiV1AskPostResponse200) & {
  headers: Headers;
};
export type askApiV1AskPostResponseError = (askApiV1AskPostResponse422) & {
  headers: Headers;
};

export type askApiV1AskPostResponse = (askApiV1AskPostResponseSuccess | askApiV1AskPostResponseError)

export const getAskApiV1AskPostUrl = () => {


  

  return `/api/v1/ask`
}

export const askApiV1AskPost = async (queryReq: QueryReq, options?: RequestInit): Promise<askApiV1AskPostResponse> => {
  
  const res = await fetch(getAskApiV1AskPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      queryReq,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: askApiV1AskPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as askApiV1AskPostResponse
}



/**
 * R: Enhanced health check that verifies system dependencies.

Args:
    full: If True, also check Google API connectivity (slower)

Returns:
    ok: True if all checked systems operational
    db: "connected" or "disconnected"
    google: "available", "unavailable", or "disabled" (only with full=true)
    request_id: Correlation ID for this request
 * @summary Healthz
 */
export type healthzHealthzGetResponse200 = {
  data: unknown
  status: 200
}

export type healthzHealthzGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type healthzHealthzGetResponseSuccess = (healthzHealthzGetResponse200) & {
  headers: Headers;
};
export type healthzHealthzGetResponseError = (healthzHealthzGetResponse422) & {
  headers: Headers;
};

export type healthzHealthzGetResponse = (healthzHealthzGetResponseSuccess | healthzHealthzGetResponseError)

export const getHealthzHealthzGetUrl = (params?: HealthzHealthzGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/healthz?${stringifiedParams}` : `/healthz`
}

export const healthzHealthzGet = async (params?: HealthzHealthzGetParams, options?: RequestInit): Promise<healthzHealthzGetResponse> => {
  
  const res = await fetch(getHealthzHealthzGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: healthzHealthzGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as healthzHealthzGetResponse
}



/**
 * R: Expose Prometheus metrics.

Returns:
    Prometheus text format metrics
 * @summary Metrics
 */
export type metricsMetricsGetResponse200 = {
  data: unknown
  status: 200
}
    
export type metricsMetricsGetResponseSuccess = (metricsMetricsGetResponse200) & {
  headers: Headers;
};
;

export type metricsMetricsGetResponse = (metricsMetricsGetResponseSuccess)

export const getMetricsMetricsGetUrl = () => {


  

  return `/metrics`
}

export const metricsMetricsGet = async ( options?: RequestInit): Promise<metricsMetricsGetResponse> => {
  
  const res = await fetch(getMetricsMetricsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: metricsMetricsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as metricsMetricsGetResponse
}
