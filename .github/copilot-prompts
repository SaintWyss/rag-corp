@workspace Quiero una auditoría completa del repo.

Objetivo: entender qué tenemos hoy. NO modifiques archivos todavía.

Entregables:
1) Resumen de arquitectura: componentes, responsabilidades, flujo de datos principal (ingesta → embeddings → almacenamiento → retrieval → respuesta).
2) Mapa de carpetas: qué rol cumple cada carpeta y por qué existe.
3) Evaluación de buenas prácticas: separación de capas, naming, manejo de errores, tipado/contratos, configuración, logging/observabilidad, seguridad, tests.
4) Deuda técnica priorizada: Top 10 issues (impacto alto → bajo) con evidencia (rutas/archivos relevantes).
5) Quick wins (1–2 horas) y mejoras medianas (1–2 días), con pasos concretos.
6) Checklist para correr local (si lo encontrás en README/compose/scripts).

Formato:
- Usá bullets claros.
- Citá archivos/rutas exactas cuando afirmes algo.
- Explicámelo “para Santiago” (nivel estudiante de Ing. en Sistemas, pero con rigor).


@workspace Quiero mejorar la arquitectura del proyecto aplicando diseño de sistemas, SOLID y patrones de diseño, sin “romper” el producto.

Reglas:
- Primero proponé un PLAN en fases (Fase 1, 2, 3) con objetivos, riesgos y criterio de “done”.
- Cambios incrementales: cada fase debe ser un conjunto pequeño de PRs.
- En cada PR: lista de archivos tocados, qué cambia, por qué, y cómo probarlo.
- No reescribas todo. Preferí refactors guiados por casos de uso.
- Priorizá límites claros (por ejemplo: dominio/use-cases vs infraestructura/adapters).
- Diseñá interfaces para proveedores externos (LLM/embeddings/vector store) con inyección de dependencias.
- Asegurá contrato FE/BE consistente (tipos/validación) y mejora manejo de errores.

Entregables:
1) “Arquitectura objetivo” (diagrama textual) + motivos.
2) Patrones propuestos y dónde aplicar (Repository, Service, Adapter/Port, Facade, Strategy, etc.).
3) Plan por fases con PRs.
4) Primer PR propuesto en detalle (pasos exactos).

Si necesitás elegir entre alternativas, proponé 2 opciones y recomendá una.


@workspace Quiero que adaptes los comentarios y documentación interna del código al estilo CRC Cards.

Objetivo:
- Cada módulo/clase/componente principal debe tener un bloque de comentario inicial con:
  - Name (Class/Component/Module)
  - Responsibilities (3–7 bullets)
  - Collaborators (dependencias directas)
  - Notes/Constraints (invariantes, performance, seguridad, decisiones)
- En TS/React usar JSDoc /** ... */.
- En Python usar docstring triple quotes.
- Evitar comentarios redundantes; comentar intención, reglas de negocio y arquitectura.

Proceso:
1) Identificá los “principales” (top N archivos críticos).
2) Mostrame primero una lista de archivos que vas a comentar y por qué.
3) Luego generá los bloques CRC listos para insertar (por archivo), sin inventar funcionalidades.
4) Si hay nombres confusos, sugerí renames (sin ejecutarlos todavía).


@workspace Quiero una documentación profesional del proyecto.

Tareas:
1) Crear un README.md raíz completo, que funcione como “portal”:
   - Qué es el proyecto, qué problema resuelve, features, stack, arquitectura high-level
   - Quickstart local (requisitos, env, comandos, docker compose si aplica)
   - Estructura del repo (carpetas) con explicación breve
   - Links a documentación detallada en /doc
   - Roadmap / TODOs

2) Crear carpeta /doc con esta estructura mínima:
   - doc/INDEX.md (índice de documentación técnica)
   - doc/architecture/overview.md
   - doc/architecture/decisions/ (ADRs)
   - doc/design/patterns.md (por qué y dónde)
   - doc/api/http-api.md (endpoints, contratos, errores)
   - doc/data/postgres-schema.md (tablas, índices, pgvector, migraciones)
   - doc/runbook/local-dev.md (cómo correr, troubleshooting)
   - doc/quality/testing.md (estrategia de tests)
   - doc/diagrams/ (Mermaid)

3) En cada doc: orden claro, ejemplos mínimos, y “cómo extender”.

Reglas:
- No inventes comandos: basate en lo que exista en scripts/README/compose.
- Si falta algo, dejá un “TODO” explícito.
- Proponé también 2–3 diagramas Mermaid para doc/diagrams (secuencia y componentes).
