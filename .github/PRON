REGLAS GLOBALES

- Modo SIN CAMBIOS: no modificar archivos, no commits.
- Modo 1 COMMIT: cambios directos + 1 commit final (sin ramas/PR).
- NO CAMBIOS FUNCIONALES (salvo prompts de feature/test/obs que lo pidan explicitamente).
- CERO INVENCION: toda afirmacion importante debe citar rutas reales; si no existe -> NO ENCONTRADO + TODO(verify).
- SALIDA: no pegar archivos completos; entregar unified diff/patch + lista de archivos tocados.
- Repo layout canonical: apps/backend, apps/frontend, shared/contracts, infra, docs, tests.

---

@workspace

# PRON BASELINE (AUDITORIA + % PROGRESO) - SIN CAMBIOS

Objetivo: informe maestro verificable (TO-BE vs AS-IS) + % progreso + gaps bloqueantes para deploy.
Prohibido modificar archivos (0 edits, 0 commits).

REGLAS DURAS

- MODO: SOLO LECTURA. No crear/editar/formattear archivos.
- CERO INVENCION: toda afirmacion clave debe tener evidencia con ruta + lineas.
  - Si falta: NO ENCONTRADO + TODO(verify).
- No leer todo el repo: usar SOLO fuentes + busquedas puntuales (rg/grep).
- Citas obligatorias: path:lineStart-lineEnd + snippet breve (max 8 lineas).
  - Tip: usar `nl -ba <file> | sed -n 'X,Yp'`.

FUENTES DE VERDAD (PRIORIDAD - USAR EN ESTE ORDEN) 0) docs/project/guia_definitiva_de_produccion_rag_corp.md

1. docs/project/guia_definitiva_de_readme_rag_corp_raiz_padres_y_hojas.md
2. docs/project/informe_de_negocio_brd_srs_rag_corp.md
3. docs/project/informe_de_sistemas_rag_corp.md
4. docs/requirements/functional.md + docs/requirements/non-functional.md
5. docs/reference/** + docs/architecture/** (ADRs + diagrams)
6. shared/contracts/openapi.json
7. apps/backend/alembic/versions/\*\* (migraciones)
8. apps/backend/app/main.py + apps/backend/app/interfaces/api/http/** + apps/backend/app/crosscutting/**
9. apps/frontend/app/** + apps/frontend/src/** + apps/frontend/middleware.ts + apps/frontend/next.config.mjs
10. infra/** + compose\*.yaml + .github/workflows/** + package.json
    Si una ruta no existe: reportar NO ENCONTRADO y seguir.

SANITY CHECKS (antes de analizar)
A) Verificar existencia de las 4 fuentes top (0..3).
B) Verificar que shared/contracts/openapi.json existe.
C) Verificar workflows:

- .github/workflows/ci.yml existe
- .github/workflows/deploy.yml existe
  D) Verificar referencias rotas:
- Todo Dockerfile path en workflows debe existir.
- Todo compose\*.yaml citado en docs debe existir.
- Si hay mismatch: marcar como GAP BLOQUEANTE con evidencia.

METODO (EJECUCION MINIMA, SIN SALTOS)

1. CONTRATO BASELINE (TO-BE) - 15 a 25 bullets maximo

- Extraer del conjunto docs/project/_ + docs/requirements/_
- Cada bullet debe tener 1 evidencia (ruta + lineas).
- Enfocar en: producto, seguridad, operacion, calidad, observabilidad, documentacion.

2. SNAPSHOT AS-IS (solo hechos verificables)

- Stack: FE / BE / DB / Queue-Worker / Storage / Obs / CI / Deploy (1-2 bullets c/u)
- Para cada item: 1 evidencia (ruta + lineas).
- Comandos reales: SOLO scripts existentes en package.json (root y apps/frontend) y docs/runbook si coincide.

3. MATRIZ DE CUMPLIMIENTO (tabla compacta, 6 areas)
   Areas:

- Producto (Workspaces/ACL/Scoping/RAG)
- Seguridad/Gobernanza (Auth/RBAC/headers/secrets/metrics auth)
- Operacion/Deploy (compose/k8s/release/rollback/backup/DR)
- Calidad (tests/CI/contracts/RFC7807)
- Observabilidad (health/ready/metrics/logs/dashboards)
- Documentacion (canon/stubs/drift/runbooks)
  Para cada area:
- Estado: ✅ / ⚠️ / ❌
- Evidencias: 2 (rutas + lineas)
- Riesgo: 1 linea
- Accion minima: 1 linea (fix incremental)

4. % PROGRESO (con formula explicita)

- Definir pesos (suman 100) SOLO por las 6 areas.
- Pesos recomendados (prod-ready):
  - Seguridad 25
  - Operacion/Deploy 25
  - Producto 20
  - Calidad 15
  - Observabilidad 10
  - Documentacion 5
- Score: ✅=1, ⚠️=0.5, ❌=0
- Progreso = sumatoria(peso_area \* score_area)
- Mostrar tabla: Area | Peso | Estado | Score | Contrib | Evidencias.

5. TOP 10 GAPS BLOQUEANTES (solo los que frenan prod)
   Formato fijo por gap (1 linea):
   [Area] Gap - Impacto - Evidencia (path:lines) - Fix minimo
   Regla: al menos 6/10 deben ser deploy blockers o security blockers.

6. DONE BASELINE CHECKLIST (10-15 items)
   Cada item debe incluir:

- Evidencia (path:lines)
- Comando de verificacion real (script/compose/pytest/pnpm/curl) o TODO(verify)

7. CIERRE

- % total final
- 3 fortalezas (con evidencia)
- 3 riesgos (con evidencia)
- 1 proximo paso inmediato (con evidencia)

SALIDA (FORMATO CONSTANTE)

1. CONTRATO baseline (15-25 bullets + evidencias)
2. AS-IS snapshot (stack + comandos + evidencias)
3. MATRIZ (tabla)
4. % PROGRESO (tabla + formula)
5. TOP 10 GAPS (10 lineas)
6. DONE checklist (10-15 checks)
7. CIERRE

---

@workspace

# PRON DEUDA TECNICA + QUICK WINS - SIN CAMBIOS

Objetivo: backlog senior baseline (solo evidencia) con Top 10 + quick wins + medianas + no tocar.

REGLAS

- MODO: SIN CAMBIOS.
- CERO INVENCION: cada item debe citar 2 evidencias (path:lines).
- Incremental only: prohibidas re-arquitecturas.
- Usar mismas FUENTES (prioridad) que la auditoria.

METODO
A) Detectar hallazgos: listar 20-30 candidatos (bullets) con rutas.
B) Priorizar Top 10 (riesgo/impacto/urgencia/CI/deploy).
C) Clasificar resto: Quick Wins (<=2h) y Medianas (1-2d).
D) Marcar No tocar todavia (3-5) por riesgo/ambiguedad/out-of-scope.

FORMATO ESTRICTO (max 6 lineas por item)
[ID] Titulo corto

- Impacto: Alto|Medio|Bajo | Riesgo: Seguridad|Perf|Mantenibilidad|UX (1-2)
- Evidencia: path1:lines ; path2:lines
- Problema: 1 linea
- Fix (incremental): 1-2 lineas
- Validacion: comando real (script/compose/pytest/pnpm/curl) o TODO(verify)

ENTREGABLES

1. TOP 10 DEUDA (10 items)
2. QUICK WINS (5-12 items, <=2h)
3. MEDIANAS (5-10 items, 1-2d)
4. NO TOCAR TODAVIA (3-5 items, con por que 1 linea)
5. ORDEN DE EJECUCION (1..N) con dependencias (max 8 lineas)

---

@workspace

# PRON OBSERVABILIDAD (AUDIT + METRICAS) - 1 COMMIT

Objetivo: trazabilidad y metricas accionables alineadas a Workspaces, sin ruido.

REGLAS

- 1 COMMIT, sin rama/PR. Commit: `feat(obs): workspace audit + metrics alignment (baseline)`
- No inventar eventos/metricas: basarse en flujos reales y docs baseline.
- Labels razonables (evitar cardinalidad alta).
- Mantener Clean Architecture: emision en app layer cuando corresponda.

TAREAS

1. Auditoria:
   - Asegurar eventos criticos: workspace._, doc._, auth._, admin.user._ (solo si existen en contrato).
   - Incluir workspace_id donde aplique.
2. Metricas:
   - Counters/histograms para ask latency, retrieval latency, ingest pipeline, worker processing, errors.
   - Cache hit/miss solo si existe.
   - Proteger /metrics segun config real.
3. Docs:
   - Actualizar docs de observabilidad si existe seccion; si no, agregar doc minimo en docs/observability/\*\* y linkear en indice.
4. Tests minimos:
   - Que la emision de audit no rompa y que metricas expongan nombres esperados.
5. Validacion:
   - `cd apps/backend && pytest -q`

SALIDA FINAL

- Archivos tocados
- Lista de metricas/eventos agregados (corto)
- Comandos corridos + resultado
- TODOs (si faltaron soportes reales)

---

@workspace

# PRON CI1 - HYGIENE + STABILITY (1 COMMIT)

Objetivo: arreglar CI que falla por configuracion (paths/scripts/caches/timeouts/perms) sin tocar producto.

REGLAS

- 1 COMMIT, sin rama/PR. Commit: `chore(ci): hygiene + stability (baseline)`
- Prohibido tocar logica de negocio. Permitido: .github/workflows/\*\*, docs/quality/testing.md, configs de tooling (solo si afecta CI), scripts no funcionales.
- No cambiar triggers (on:), ni estrategia/matriz de jobs; solo alinear y estabilizar.
- CERO INVENCION: cada cambio debe referenciar evidencia (ruta real + error que corrige).
- Output: unified diff/patch (no archivos completos).

PASO 1 - DIAGNOSTICO (sin cambios)

- Leer TODOS .github/workflows/\*.yml
- Listar fallas potenciales por categoria:
  A) paths inexistentes, B) scripts inexistentes, C) caches mal apuntados, D) coverage paths, E) timeouts, F) permisos.
- Evidencia por item: linea o snippet + ruta.

PASO 2 - FIXES (minimos)

- Paths: corregir a layout real (apps/backend, apps/frontend, shared/contracts, tests, infra).
- Scripts: usar scripts reales de package.json; si falta, NO inventar -> TODO(verify).
- Cache:
  - pnpm: cache-dependency-path a pnpm-lock.yaml real
  - python: requirements.txt real y/o uv/poetry si existe
- Coverage: apuntar a la ruta real de coverage.xml/lcov.info si existe; si no existe, NO agregar coverage nuevo.
- Timeouts: subir solo donde sea claro que es E2E pesado (sin exagerar).
- Permissions: agregar permissions minimos si faltan (read-only por defecto).

PASO 3 - DOC (si cambio algo visible)

- Actualizar docs/quality/testing.md (solo notas de como corre CI y comandos equivalentes locales).

VALIDACION (obligatoria)

- Verificar que workflows no referencien paths inexistentes (grep/lista).
- Listar comandos locales equivalentes (solo si existen).

SALIDA FINAL

- Archivos tocados
- Top 10 fixes (<=10 bullets)
- TODOs de verificacion

---

@workspace

# PRON CI2 - TEST STABILITY (1 COMMIT)

Objetivo: reducir flakes y hacer tests deterministas para CI.

REGLAS

- 1 COMMIT, sin rama/PR. Commit: `test(ci): stabilize test suite (baseline)`
- Permitido: tests/\*\*, config de test (pytest.ini/playwright.config), scripts de test, fixtures/seeds.
- Prohibido: cambios de producto (endpoints/negocio/UI behavior). Si un test requiere cambio funcional -> NO hacerlo aqui, dejar TODO y pasar a CI3.
- CERO INVENCION: endpoints/flows deben venir de OpenAPI/routes reales.
- Output: unified diff/patch.

PASO 1 - MAPEO DE TESTS

- Identificar que corre en CI (workflows) y que scripts llama.
- Clasificar tests: unit / integration / e2e / load.
- Detectar flake patterns: waits, timeouts, random data, dependencia de red/keys.

PASO 2 - FIXES PERMITIDOS (determinismo)

- E2E:
  - waits por readiness real (healthz/readyz) y condiciones visibles
  - selectors estables (data-testid si ya existe; si no existe, NO tocar UI en este prompt)
  - timeouts razonables y retries controlados (solo en e2e)
  - seeds/fixtures deterministas (FAKE_LLM/FAKE_EMBEDDINGS si existen)
- Backend tests:
  - aislar dependencias externas (fake flags si existen)
  - limpiar datos entre tests (fixtures) sin tocar logica app
- Asegurar artifacts utiles (screenshots/videos/logs) si ya esta configurado.

VALIDACION

- Backend: `cd apps/backend && pytest -q`
- Frontend: `cd apps/frontend && pnpm lint && pnpm tsc --noEmit` (si el workflow lo corre)
- E2E: `pnpm -C tests/e2e test` (si existe script)

SALIDA FINAL

- Archivos tocados
- Flakes mitigados (<=8 bullets)
- TODOs que requieren cambios de producto (para CI3)

---

@workspace

# PRON CI3 - BUGFIXES POR CI ROJO (1 COMMIT)

Objetivo: arreglar bugs reales detectados por CI (tests rojos), con cambios minimos y verificados.

REGLAS

- 1 COMMIT, sin rama/PR. Commit: `fix(ci): resolve failing tests (baseline)`
- Cambios minimos: tocar solo lo necesario para que tests pasen.
- No refactors grandes. No cambios de API/contratos/migraciones salvo que el test lo exija explicitamente y haya evidencia.
- Cada fix debe incluir:
  - causa raiz (1-2 lineas)
  - evidencia (log/test + ruta)
  - cambio minimo (diff)
- Output: unified diff/patch.

PASO 1 - IDENTIFICAR FALLAS

- Tomar fallas actuales (logs de CI o correr tests local).
- Agrupar por causa: backend/runtime/config/frontend/e2e.

PASO 2 - APLICAR FIXES

- Fixes pequenos, especificos, con pruebas.
- Si la falla es por dependencia externa (keys/red):
  - preferir fakes/flags ya existentes antes que integrar servicios reales.
- Si la falla es por readiness/race:
  - preferir arreglar el readiness del servicio o el contrato del test, segun evidencia.

VALIDACION

- Re-correr exactamente los comandos que fallaban.
- Verificar `git diff` solo incluye cambios necesarios.

SALIDA FINAL

- Archivos tocados
- Lista de fallas corregidas (<=10)
- Comandos corridos + resultado

---

@workspace

# PRON DOCS - AUDIT + APPLY (Docs only)

Objetivo: (1) auditar docs+READMEs y detectar drift contra el repo real; (2) opcionalmente aplicar fixes SOLO en docs, en 1 commit.
Modo: elegir UNO al inicio: AUDIT (SIN CAMBIOS) o APPLY (1 COMMIT).

MODO (seleccionar)

- AUDIT = SIN CAMBIOS (0 edits/0 commits). Solo reporte.
- APPLY = SOLO DOCS (README.md + docs/\*\*) y 1 commit final: `docs(baseline): align documentation with repo state`
  Regla: si el modo no esta explicito -> asumir AUDIT.

REGLAS GENERALES

- CERO INVENCION: comandos/endpoints/env/scripts deben venir de fuentes reales. Si no verificable: TODO(verify).
- Scope docs: solo README.md, docs/**, y todos los **/README.md trackeados (para inventario). En APPLY solo tocar README.md y docs/\*\*.
- Evidencia: cada drift/hallazgo debe citar (Doc ruta) + (Fuente real ruta).
- Salida compacta: tablas/listas, sin texto largo.

FUENTES DE VERDAD (comparacion)

1. shared/contracts/openapi.json
2. apps/backend/alembic/versions/\*\*
3. compose\*.yaml + infra/\*\*
4. .github/workflows/\*\*
5. package.json / pnpm-workspace.yaml / turbo.json
6. apps/backend/** y apps/frontend/** (solo para verificar paths mencionados en docs)

PASO 1 - INVENTARIO (siempre, AUDIT y APPLY)
A) Enumerar:

- root README.md
- todos los \*\*/README.md trackeados
- docs/\*\* (por carpetas)
- .github/\*\* docs (si existen)
  B) Clasificar cada doc: Canonical | Supporting | Historical | Deprecated
  C) Marcar estado: ✅ existe y consistente | ⚠️ existe con drift | ❌ falta pero deberia existir

PASO 2 - DRIFT REPORT (siempre, 15-30 hallazgos)
Formato fijo por hallazgo (3 lineas):

- Doc: <ruta>#<seccion>
- Contradiccion: <afirma X> vs <fuente real + ruta>
- Fix esperado: 1 linea (sin inventar)

Prioridad de drift:

1. comandos que no existen (scripts)
2. servicios/puertos/perfiles incorrectos (compose)
3. endpoints no presentes en OpenAPI
4. DB schema no coincide con migraciones
5. paths inexistentes
6. features prometidas pero no implementadas (pasar a TODO/Roadmap)

PASO 3 - DOCS OBJETIVO baseline (siempre)
Listar 8-14 docs minimos canonicos (path + proposito 1 linea) y estado ✅/⚠️/❌.
Incluye minimo:

- README.md (portal)
- docs/README.md (indice)
- docs/runbook/local-dev.md
- docs/api/http-api.md
- docs/data/postgres-schema.md
- docs/architecture/overview.md
- docs/quality/testing.md
- docs/system/\*\* (contrato baseline)
- docs/observability/\*\* (si aplica)

PASO 4 - APPLY (solo si MODO=APPLY)
Restriccion para ahorrar tokens y evitar expansion:

- Max archivos tocados: 12-16 (si hay mas, priorizar y dejar TODO listados).
- No crear docs nuevas excepto: docs/README.md si falta, y 1-2 docs canonicas faltantes.
- No tocar codigo ni configs fuera de docs.

Tareas de APPLY (orden):

1. README.md como portal (corto y real):
   - que es (3-6 bullets verificables)
   - features implementadas (solo lo que exista)
   - stack (tabla)
   - quickstart: env minima + comandos reales + 1 verificacion curl
   - estructura repo (1 linea por carpeta)
   - links a docs/README.md
   - roadmap (5-10 TODOs verificables)
2. docs/README.md indice canonico (links vivos)
3. Alinear docs canonicas con evidencia:
   - local-dev (compose/scripts)
   - http-api (OpenAPI)
   - postgres-schema (migraciones)
   - testing (workflows/scripts)
   - architecture overview (sin inventar; TODO si falta)
4. Diagramas Mermaid: max 2 (component + 1 sequence clave). Si falta info: TODO(verify).

VALIDACION (en APPLY)

- Check links: que todos los paths referenciados existan.
- pnpm contracts:gen (si existe) y no rompe.
- Si no se puede correr algo: explicar 1 linea.

SALIDA FINAL (formato fijo)

1. INVENTARIO (tabla: ruta | tipo | estado | nota 1 linea)
2. DRIFT TOP 15-30
3. DOCS OBJETIVO baseline
4. PRIORIZACION (Top 10 acciones)
5. Si APPLY:
   - diff/patch (no archivos completos)
   - archivos tocados
   - resumen <=10 bullets
   - commit: `docs(baseline): align documentation with repo state`
   - TODOs que quedaron

---

@workspace

# PRON vCLEAN - LIMPIEZA TOTAL DEL REPO (higiene + consistencia) - 1 COMMIT

Objetivo: dejar el repo ordenado, consistente y CI-ready sin cambiar behavior.
Regla clave: todo en 1 commit final: `chore(repo): cleanup hygiene (baseline)`.

NO HACER

- No cambios funcionales (endpoints, payloads, authz, queries, pipeline, UI behavior).
- No refactors grandes, no re-arquitectura, no tocar migraciones.
- No crear ramas/PR.

SI HACER (solo higiene)

- Eliminar basura trackeada, endurecer ignores, ordenar configs, docs menores, consistencia.
- Quitar debug obvio (prints/logs) SOLO si es inequivocamente debug y no parte del sistema.
- Eliminar dead code SOLO con evidencia de 0 uso (rg + imports + scripts).

FASE 1 - INVENTARIO (solo lectura, sin borrar)

1. Listar archivos trackeados candidatos basura:
   - caches: **pycache** .pytest_cache .ruff_cache .mypy_cache
   - cobertura: .coverage\* coverage/ coverage.xml
   - build: dist/ build/ .next/ node_modules/
   - tests: playwright-report/ test-results/
   - logs/tmp: _.log _.tmp _.bak _.DS_Store

   Comandos:
   - git ls-files | rg -n "**pycache**|\.pytest_cache|\.ruff_cache|\.mypy_cache|(^|/)\.coverage|(^|/)coverage/|coverage\.xml|(^|/)dist/|(^|/)build/|(^|/)\.next/|node_modules|playwright-report|test-results|\.log$|\.tmp$|\.bak$|\.DS_Store$"
   - git ls-files -z | xargs -0 -I{} bash -lc 'test -f "{}" && wc -c "{}" | awk "$1>1000000"' | head

2. Detectar obsoleto (candidatos a borrar):
   - carpetas/docs con old|deprecated|archive|history
   - PDFs/exports antiguos en docs si no se usan
   - duplicados de docs reemplazados por baseline

   Comandos:
   - git ls-files | rg -n "(^docs/.\*(old|deprecated|archive|history)|(^|/)(old|deprecated)/)"
   - git ls-files | rg -n "(deprecated)"
   - rg -n "(docs/(archive|history)|deprecated)" docs || true

3. Para cada candidato a borrar, demostrar NO-USO:
   - rg -n "<nombre_archivo_o_path>" .
   - revisar imports, scripts/package.json, workflows, compose, docs links.
     Si hay 1 match relevante -> NO BORRAR (marcar TODO).

Evidencia:

- Crear docs/runbook/repo-cleanup-baseline.md con:
  - Hallazgos (rutas exactas)
  - Evidencia de no-uso (1-3 lineas por item: "rg ... -> 0 results")
  - TODOs dudosos

FASE 2 - PLAN (max 10 bullets, en el mismo runbook)

- remover basura trackeada + git rm
- reforzar .gitignore y .dockerignore (sin afectar runtime)
- limpieza obsoleta (solo si no hay referencias)
- normalizar docs links (solo links/typos; no cambiar contenido contractual)
- correr checks minimos

FASE 3 - EJECUCION (cambios reales, 1 commit)
A) Basura/artefactos (solo si trackeados):

- Eliminar (git rm) candidatos confirmados.
- Cookies/token files: SIEMPRE borrar si trackeados (cookies.txt, cookies*.txt, *.cookies, _token_ si es claramente secreto).

B) .gitignore / .dockerignore (higiene)

- Asegurar ignore de:
  **pycache**/ .pytest_cache/ .ruff_cache/ .mypy_cache/
  .coverage* coverage/ coverage.xml
  dist/ build/ .next/ node_modules/
  playwright-report/ test-results/
  *.log _.tmp _.bak .DS_Store
  cookies.txt cookies\*.txt
- Si falta .dockerignore, crear uno minimo (sin romper builds):
  ignorar node_modules, .next, dist, build, caches, test artifacts, docs pesados opcional.

C) Obsoleto (borrado total con guardrails)

- Borrar solo si:
  1.  esta en docs/archive o docs/history, o tiene nombre claramente viejo y es docs/config no usado
  2.  rg no muestra referencias reales desde docs, workflows, package.json, compose/infra, tests
- Si hay duda: NO BORRAR. Agregar TODO en el runbook.

D) Tooling sin cambiar behavior

- Backend: ordenar imports/format SOLO si ya esta configurado (ruff).
- Frontend: no tocar logica; solo lint/ts fixes que no cambien behavior.
- Contracts: correr generator si existe y asegurar 0 diff.

FASE 4 - VALIDACION (obligatoria)
Backend:

- cd apps/backend && ruff check .
- cd apps/backend && ruff format --check .
- cd apps/backend && pytest -q

Frontend:

- cd apps/frontend && pnpm install --frozen-lockfile
- cd apps/frontend && pnpm lint
- cd apps/frontend && pnpm tsc --noEmit

Contracts (si aplica):

- pnpm contracts:gen
- git diff --exit-code shared/contracts/ || true

E2E (opcional si es pesado; si no corre, justificar):

- pnpm -C tests/e2e test

FASE 5 - COMMIT UNICO

- Asegurar git status con SOLO cambios esperados.
- Commit: `chore(repo): cleanup hygiene (baseline)`

SALIDA FINAL (en docs/runbook/repo-cleanup-baseline.md)

- Estado: ✅/⚠️
- Archivos tocados
- Resumen (<=10 bullets)
- Que eliminaste y evidencia (rg 0 results)
- Comandos corridos + resultado
- TODOs que quedaron
