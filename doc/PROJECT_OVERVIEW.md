# RAG Corp Project Overview

Last updated: 2026-01-03

## Purpose

RAG Corp is a Retrieval-Augmented Generation system that lets users ingest documents, search them semantically, and ask questions that are answered by a large language model grounded in retrieved context. The system is built to keep answers traceable to source text and reduce hallucinations.

## High-Level Architecture

```
User
  |
  v
Next.js Web UI  --->  FastAPI Backend  --->  PostgreSQL + pgvector
                               |                     ^
                               v                     |
                         Google Gemini APIs (embeddings + LLM)
```

## Core Components and How They Relate

### Frontend (Next.js)
- Location: `frontend/`
- Role: UI for asking questions and viewing answers and sources.
- Uses generated TypeScript client from `shared/contracts/` to call the backend.
- Main logic:
  - `frontend/app/page.tsx`: main page UI and wiring.
  - `frontend/app/hooks/useRagAsk.ts`: encapsulates ask flow and error handling.

### Backend (FastAPI)
- Location: `backend/`
- Role: HTTP API, orchestration, and business logic for ingest/query/ask.
- Clean Architecture layering:
  - Domain: `backend/app/domain/` (entities and protocols).
  - Application: `backend/app/application/` (use cases).
  - Infrastructure: `backend/app/infrastructure/` (DB, external services, chunking).
  - API: `backend/app/main.py`, `backend/app/routes.py` (HTTP layer).
- Key glue:
  - `backend/app/container.py`: dependency injection providers.
  - `backend/app/infrastructure/db/`: connection pool and DB access.

### Shared Contracts (OpenAPI -> TS)
- Location: `shared/contracts/`
- Role: single source of truth for API contracts.
- Flow:
  1) FastAPI exports OpenAPI to `shared/contracts/openapi.json`.
  2) Orval generates `shared/contracts/src/generated.ts`.
  3) Frontend imports the client for typed API calls.

### Database (PostgreSQL + pgvector)
- Schema: `infra/postgres/init.sql` and docs in `doc/data/postgres-schema.md`.
- Tables:
  - `documents`: document metadata.
  - `chunks`: chunk text + vector embeddings.
- Vector search uses cosine distance with pgvector indexes.

### Infrastructure / Ops
- Compose: `compose.yaml` and variants for local/prod.
- Metrics: Prometheus endpoint at `/metrics`.
- Logging: JSON logs with request correlation and timing.

## Data Flows (End to End)

### 1) Ingest (POST `/v1/ingest/text`)
1. Client submits a document (title, text, optional source/metadata).
2. Backend validates and chunks the text.
3. Embedding service computes vectors.
4. Repository stores document + chunks in Postgres.
5. API returns `document_id` and chunk count.

### 2) Query (POST `/v1/query`)
1. Query is embedded.
2. Vector search retrieves top-k chunks.
3. API returns matches with similarity scores.

### 3) Ask (POST `/v1/ask`)
1. Query is embedded.
2. Vector search retrieves top-k chunks.
3. ContextBuilder formats a context prompt from chunks.
4. LLM generates an answer grounded in the context.
5. API returns the answer plus sources.

## Backend Architecture Details

### Domain Layer (`backend/app/domain`)
- Entities: `Document`, `Chunk`, `QueryResult`.
- Protocols: `DocumentRepository`, `EmbeddingService`, `LLMService`, `TextChunkerService`.
- Pure Python, no framework dependencies.

### Application Layer (`backend/app/application`)
- Use cases:
  - `IngestDocumentUseCase`
  - `SearchChunksUseCase`
  - `AnswerQueryUseCase`
- Explicit input/output DTOs to keep orchestration testable.

### Infrastructure Layer (`backend/app/infrastructure`)
- Repository: `PostgresDocumentRepository`
- External services: Google Gemini embedding + LLM wrappers
- Chunking: `SimpleTextChunker` and semantic chunker options
- Prompt templates: `backend/app/prompts/` + `PromptLoader`

### API Layer
- `backend/app/routes.py`: HTTP endpoints + request/response models.
- `backend/app/main.py`: app setup, middleware, CORS, and lifespan.
- Versioned routes also available under `/api/v1`.

## Frontend Architecture Details

- Next.js App Router with Tailwind for UI.
- Primary flow uses `useRagAsk` hook to:
  - manage state (query, answer, sources, loading, error),
  - call `askV1AskPost` from generated contracts,
  - handle HTTP errors and timeouts.

## Contracts and Type Safety

- OpenAPI spec is generated by the backend.
- Orval generates a typed client for frontend usage.
- This keeps request/response models aligned across FE/BE.

## Security and Safety Controls

- API key auth via `X-API-Key` with scoped permissions.
- Rate limiting (token bucket) configurable by env vars.
- Request body size limit (default 10MB).
- Prompt includes explicit grounding and prompt-injection rules.

## Observability

- JSON structured logs with request_id and timing fields.
- Prometheus metrics at `/metrics`.
- Health check at `/healthz`.

## Testing

- Backend: unit + integration tests in `backend/tests/`.
- Frontend: React component and hook tests in `frontend/__tests__/`.
- Contract checks ensure OpenAPI and generated code stay in sync.

## Local Development (Summary)

1. `cp .env.example .env` and set `GOOGLE_API_KEY`
2. `pnpm install`
3. `pnpm docker:up`
4. `pnpm contracts:export` and `pnpm contracts:gen`
5. `pnpm dev`

## Repo Map (Short)

```
backend/              # FastAPI API + RAG logic
frontend/             # Next.js UI
shared/contracts/     # OpenAPI spec + generated TS client
infra/                # DB schema and infra assets
doc/                  # Architecture, API, runbooks
tests/                # Load testing assets
```

## Where to Look Next

- Architecture: `doc/architecture/overview.md`
- API: `doc/api/http-api.md`
- DB schema: `doc/data/postgres-schema.md`
- Local runbook: `doc/runbook/local-dev.md`
